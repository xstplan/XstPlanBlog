{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"source/Img/0231125155322.png","path":"Img/0231125155322.png","modified":1,"renderable":0},{"_id":"source/Img/2023122311111.png","path":"Img/2023122311111.png","modified":1,"renderable":0},{"_id":"source/Img/20231016195905.png","path":"Img/20231016195905.png","modified":1,"renderable":0},{"_id":"source/Img/230231125155410.png","path":"Img/230231125155410.png","modified":1,"renderable":0},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/author.jpg","path":"img/author.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","path":"js/jquery.qrcode-0.12.0.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/Img/2023122311111.png","hash":"6677c76fab88a1bafa4f5b4721b7e3d7372e774c","modified":1703298197238},{"_id":"source/Img/20231016195905.png","hash":"eabb2e7a2b75a4f049dd4c9cb170655743f7312c","modified":1697457540950},{"_id":"source/_posts/10.其他/Git常见错误.md","hash":"7f110f8bfdd3491197c18b7129aa6852bbe9939d","modified":1703298447209},{"_id":"source/_posts/1.计算机编程/Go第二天.md","hash":"dfff932aeb75853830d7eb9a083f6a3f619ef0d6","modified":1701495435343},{"_id":"source/about.md","hash":"4b5d17f7539b1b8e92dccb94155cbf0da56db9fa","modified":1697604511426},{"_id":"source/_posts/10.其他/常用工具集合.md","hash":"caf2d66e242b2d05b9cb2a329b1bd02b0d78d9de","modified":1702869329271},{"_id":"source/_posts/1.计算机编程/Go第三天.md","hash":"99f7c08f8a49c0be6ca14b38e5fdbb60626b1c72","modified":1701495358093},{"_id":"source/_posts/2.前端笔记/ES6的第一天.md","hash":"72c99b9ab9a629fd38e63556eaf61aa2f46d7d88","modified":1700989300121},{"_id":"source/_posts/2.前端笔记/Node.js 、npm、cnpm、yran主要作用.md","hash":"212e12e9048d7ae9b13af023080767315f7e2272","modified":1697605109898},{"_id":"source/_posts/2.前端笔记/Node.js安装与配置环境(Windows版).md","hash":"d1792f597661c6f4c0c1daaf357a7e26d01478fc","modified":1701083891354},{"_id":"source/_posts/2.前端笔记/什么是HTTP.md","hash":"f2a9b3460864dbdf92d17903506b9f3d3a163dd0","modified":1701176346405},{"_id":"source/_posts/3.后端笔记/1.Net Core的NET Standard.md","hash":"11609e82a03df736b4bde3d5692f6fbbf9dc2c6b","modified":1698059444512},{"_id":"source/_posts/2.前端笔记/前端常用命令.md","hash":"73ed445dfdf423a813c15487ade0baaed9319c3f","modified":1703297965926},{"_id":"source/_posts/3.后端笔记/2.Net Core 使用NET CLI.md","hash":"57a40895a8ddbcd7be992b2c967c039c5f0b74b3","modified":1698059441742},{"_id":"source/_posts/1.计算机编程/运行时、运行库、运行环境.md","hash":"44fc35f79d16f85655ea14b9cd4c16cfcee5ef5b","modified":1697548571416},{"_id":"source/Img/230231125155410.png","hash":"96cab29dd435339b9ab80bda9d31fe57930a5e71","modified":1700898860960},{"_id":"source/_posts/10.其他/Net扩展与库.md","hash":"af4c6318604585c290951b1b3bb4cf8defea6f80","modified":1701501674122},{"_id":"source/_posts/1.计算机编程/SOLID原则.md","hash":"209dcb77c5af072d2063d497c18983d0f6670feb","modified":1697622076794},{"_id":"source/Img/0231125155322.png","hash":"cddf0574ce10dd5486bce776c1a2868165fd7d87","modified":1700898809668},{"_id":"source/_posts/1.计算机编程/Windows-Docker安装.md","hash":"4343703035e5357100a3510d3d2d0a9e64a33cb7","modified":1701090726150},{"_id":"themes/jacman/.gitignore","hash":"0d5c2fdbdc974f10150baa12e1fc171a34960ed8","modified":1700902890764},{"_id":"source/_posts/1.计算机编程/Go第一天.md","hash":"1beb4bcd4795c4a0fb832b66169bcab4b267e4e1","modified":1702897862979},{"_id":"themes/jacman/LICENSE","hash":"d8780b41bab4b87bdd21eca444cae11af72617f4","modified":1700902890764},{"_id":"themes/jacman/layout/category.ejs","hash":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1700902890797},{"_id":"themes/jacman/layout/archive.ejs","hash":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1700902890797},{"_id":"themes/jacman/layout/index.ejs","hash":"6d6c3e13ae133e90b87868327d996ad1e285f145","modified":1700906190427},{"_id":"themes/jacman/layout/page.ejs","hash":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1700902890798},{"_id":"themes/jacman/README.md","hash":"897309f4a728102054ebe916e4b907ebf41e03ae","modified":1700902890764},{"_id":"themes/jacman/layout/post.ejs","hash":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1700902890798},{"_id":"themes/jacman/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1700902890799},{"_id":"themes/jacman/layout/tag.ejs","hash":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1700902890798},{"_id":"themes/jacman/languages/default.yml","hash":"6e1460594fa50394ac6f11fe9d39dc59478ddd0c","modified":1701015948964},{"_id":"themes/jacman/languages/zh-CN.yml","hash":"6e1460594fa50394ac6f11fe9d39dc59478ddd0c","modified":1700902890781},{"_id":"themes/jacman/languages/zh-TW.yml","hash":"0e7912c6505592a10efe2db1c994ccc3ebf91239","modified":1700902890782},{"_id":"themes/jacman/layout/layout.ejs","hash":"ceeb2a7410b96b81310ed9b1279f62e953b0a6ca","modified":1700902890798},{"_id":"themes/jacman/_config.yml","hash":"7fb6f7a14ed60aba8baebe35c6b5781c837fbdce","modified":1700906360473},{"_id":"themes/jacman/layout/_partial/analytics.ejs","hash":"ebaec2ae044ada08825d8e8af9614821f779d3dd","modified":1700902890783},{"_id":"themes/jacman/layout/_partial/article_row.ejs","hash":"2c1f1edfeaebaafe4265d58e0b8110e71673da40","modified":1700902890785},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","hash":"ef6152e1f8ebe1c34214aa1a13cf40238a29dc6c","modified":1700902890782},{"_id":"themes/jacman/layout/_partial/categories.ejs","hash":"2b77ff6cbc8571cab27c3bdc4ad51a79510bbca2","modified":1700902890785},{"_id":"themes/jacman/README_zh.md","hash":"17119a321a97dd84628ed8c16c0619ef5be94cbe","modified":1700902890780},{"_id":"themes/jacman/layout/_partial/archive.ejs","hash":"ebd53913a0e0b56581b55d689136fef0919326b8","modified":1700906200065},{"_id":"themes/jacman/layout/_partial/footer.ejs","hash":"c4358de4ea1372ea68ff5dc0f4257c348d516990","modified":1700902890786},{"_id":"themes/jacman/layout/_partial/header.ejs","hash":"795435cc84c46a18e4ac597435a81f66eb86b0c4","modified":1700902890786},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","hash":"5636df1f2b6a8d02986d866e3824ec60430046e6","modified":1700902890787},{"_id":"themes/jacman/layout/_partial/pagination.ejs","hash":"6cf37f844f150af4bbe212610da61e5140317de9","modified":1700902890787},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","hash":"846d96ff73409b9a8b34f3cab691821096c03e1d","modified":1700902890791},{"_id":"themes/jacman/layout/_partial/tags.ejs","hash":"c5c858742b29e6364da2e1d098e7d6cd8cef038f","modified":1700902890791},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","hash":"67a55a4d94cca2db11a2636f1f2c92c208688b14","modified":1700902890792},{"_id":"themes/jacman/layout/_partial/totop.ejs","hash":"224d078ba1f2c33c52d5e867af71c5fe9f1bdf45","modified":1700902890792},{"_id":"themes/jacman/layout/_widget/archive.ejs","hash":"b82d7fb0d1119738a9f9bb747d415e8c99e454ae","modified":1700902890792},{"_id":"themes/jacman/layout/_widget/category.ejs","hash":"2c1b9ac7666d7d5b9aaf8f33588e10451c4b7841","modified":1700902890793},{"_id":"themes/jacman/layout/_widget/douban.ejs","hash":"6dcb532d02325d2a9f5fb92831401552a5540aa8","modified":1700902890793},{"_id":"themes/jacman/layout/_widget/github-card.ejs","hash":"91fc6aace74c733de1a9e36f78c0edb5d6f9a53d","modified":1700902890793},{"_id":"themes/jacman/layout/_widget/rss.ejs","hash":"ebfb11bdd603cd6e4dcf3949cc52e38009615c25","modified":1700902890796},{"_id":"themes/jacman/layout/_widget/links.ejs","hash":"bd73be669ddc47e1daab38736d1cecc3f37662e2","modified":1700902890793},{"_id":"themes/jacman/layout/_widget/tag.ejs","hash":"43b1c29fea51f849ec0bf85a6d91fe0507f01503","modified":1700902890796},{"_id":"themes/jacman/layout/_widget/weibo.ejs","hash":"ff7db098608ba48752964cc67a51a04965ea927e","modified":1700902890797},{"_id":"themes/jacman/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1700902890805},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","hash":"317d420f5448c7452290e37f0ed8516cb73f4068","modified":1700902890797},{"_id":"themes/jacman/layout/_partial/head.ejs","hash":"210bb4c1ec77d998dfd93baeb4e3a0b46a925cd1","modified":1700902890786},{"_id":"themes/jacman/layout/_partial/article.ejs","hash":"00c00b4a961ac1f7bc8ee688ce134fe0c454edc6","modified":1700902890783},{"_id":"themes/jacman/layout/_partial/search.ejs","hash":"732fcd909f6dac557629206dc7e93a7083cda084","modified":1700902890791},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1700902890806},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1700902890806},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1700902890807},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1700902890806},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1700902890810},{"_id":"themes/jacman/source/css/style.styl","hash":"4610c477560086880acc1ba71c3a72e7c89ecdb7","modified":1700902890804},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1700902890809},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1700902890811},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1700902890805},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1700902890809},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1700902890814},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1700902890813},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1700902890813},{"_id":"themes/jacman/source/font/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1700902890810},{"_id":"themes/jacman/source/font/fontdiao.eot","hash":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1700902890817},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1700902890816},{"_id":"themes/jacman/source/font/fontdiao.ttf","hash":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1700902890818},{"_id":"themes/jacman/source/img/author.jpg","hash":"610a2a551230c3b26317270143286817e274b06c","modified":1699418462560},{"_id":"themes/jacman/source/font/fontdiao.woff","hash":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1700902890818},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1699418462560},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1699418462560},{"_id":"themes/jacman/source/img/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1699418462560},{"_id":"themes/jacman/source/img/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1699418462560},{"_id":"themes/jacman/source/img/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1699418462560},{"_id":"themes/jacman/source/img/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1699418462560},{"_id":"themes/jacman/source/img/favicon.ico","hash":"8c39f647f6403ab93cf00b9c431cfd0d1e14006b","modified":1699418462560},{"_id":"themes/jacman/source/img/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1699418462560},{"_id":"themes/jacman/source/img/jacman.jpg","hash":"b9199e97ea8617fabc1f2fb25ba687e994f1ed3d","modified":1699418462560},{"_id":"themes/jacman/source/img/logo.png","hash":"0c619e41afa029828d30baa111da4473f267fdb3","modified":1699418462560},{"_id":"themes/jacman/source/img/logo.svg","hash":"ced9b1ea1c4ae65d4163ee87fbc4c81719aff3c8","modified":1699418462560},{"_id":"themes/jacman/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1699418462560},{"_id":"themes/jacman/source/js/gallery.js","hash":"735a714e54f0ac229f292a90df3a1f882904f6c7","modified":1700902890825},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","hash":"28ef4346743a60c896a9ae492a544c0854904350","modified":1700902890826},{"_id":"themes/jacman/source/js/totop.js","hash":"48648ec9c86e9ab491831e5a029e6f8864934149","modified":1700902890827},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","hash":"20349dcde9942885d5eae1c302ef26b1b8484f3f","modified":1700902890787},{"_id":"themes/jacman/layout/_partial/post/article.ejs","hash":"c01220f0af629f9e23bf125bdc1beef8afc206ef","modified":1700902890787},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","hash":"5c4ab6aa4c16fa55a4bc550d5fd0c715c165417a","modified":1700902890788},{"_id":"themes/jacman/source/js/jquery.qrcode-0.12.0.min.js","hash":"5f690e8588c8493eb9406aa68fbf1765aaff9476","modified":1700902890827},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","hash":"fc23ef9b5a412e05436f68ff47146b860d2d4225","modified":1700902890788},{"_id":"themes/jacman/layout/_partial/post/header.ejs","hash":"351e771b1b38244560fc52cf60d91263d3d63eef","modified":1700902890788},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1700902890807},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","hash":"5b9f5ee6a2cc8bd557550bbdc1a03d237681114e","modified":1700902890788},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","hash":"091512e19cfcf5bde2a699b211f99874f26587ad","modified":1700902890790},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","hash":"12b7360326691ebf06bea5d7ee4d54c41f64e2ec","modified":1700902890790},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1700902890807},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1700902890808},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1700902890808},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1700902890808},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1700902890809},{"_id":"themes/jacman/source/css/_partial/article.styl","hash":"0bcb684376fcbf4be42d1df5dd02c395760f7ffb","modified":1700902890802},{"_id":"themes/jacman/source/css/_base/public.styl","hash":"2c23f3f47eb768b31d4d86d56255ffb1e8bcf6c9","modified":1700902890800},{"_id":"themes/jacman/source/css/_partial/aside.styl","hash":"4746783dc7993ac45d8a0e7a9d347bfe137111fe","modified":1700902890802},{"_id":"themes/jacman/source/css/_base/font.styl","hash":"5699c270be7b28c5b2c36f453317ccd42789fd3d","modified":1700902890799},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","hash":"3ec423b734639614fbd11ec2c3445d3a03f5231d","modified":1700902890802},{"_id":"themes/jacman/source/css/_base/variable.styl","hash":"0b7d517e12102a99be82bc1a9104bb6bfd4ca10b","modified":1700902890801},{"_id":"themes/jacman/source/css/_partial/totop.styl","hash":"b48360e757d501027b7dbe093859d03795476930","modified":1700902890804},{"_id":"themes/jacman/source/css/_partial/footer.styl","hash":"0300d7d289eceb3933c1eebf38f8d10f425c1128","modified":1700902890803},{"_id":"themes/jacman/source/css/_partial/index.styl","hash":"1f9d8c513f05790742c17fc125cb6a1ad374065a","modified":1700902890804},{"_id":"themes/jacman/source/css/_partial/header.styl","hash":"f1ae52a4f41d4cfdd66cb186b0329af904fead4f","modified":1700902890803},{"_id":"themes/jacman/source/css/_base/highlight/highlight.styl","hash":"d28e71bb66101554044756033382eebbcce7eb37","modified":1700988394983},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","hash":"739808e56a56e10a03bc93d03eb55abd19590942","modified":1700902890812},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1700902890816},{"_id":"themes/jacman/source/font/fontdiao.svg","hash":"50e0247e9d39756843b7e4f720503b37bfb6154b","modified":1700902890817},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","hash":"cd981db035ec1b6f502fca78fd394c5bd438aba1","modified":1700902890826},{"_id":"themes/jacman/source/css/_partial/gallery.styl","hash":"75843d727319b1d07ad4b8c2e969036ce0d4f362","modified":1700902890803},{"_id":"themes/jacman/source/css/_base/highlight/theme.styl","hash":"d280f9ab32d7bf177adb5f7c858444cbfbac651a","modified":1700902890800},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1700902890815},{"_id":"themes/jacman/source/css/_partial/helper.styl","hash":"3ca7266a44240093143d0c55c74bb6daf579e298","modified":1700902890804},{"_id":"themes/jacman/source/img/banner.jpg","hash":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1699418462564}],"Category":[{"name":"Git常见错误","_id":"clqhfxjqk0003jkgl0nflgx5l"},{"name":"工具","_id":"clqhfxjqn0008jkgld3zq6y6z"},{"name":"前端笔记","_id":"clqhfxjqq000gjkglbp5nc6r9"},{"name":"后端笔记","_id":"clqhfxjqw0010jkglg867389d"},{"name":"设计原则","_id":"clqhfxjqx001cjkgl7mrgg3mu"}],"Data":[],"Page":[{"_content":"# 关于我\n欢迎来到我的编程笔记博客！这里是致力于分享编程知识、经验和技巧、以及记录我的学习旅程。","source":"about.md","raw":"# 关于我\n欢迎来到我的编程笔记博客！这里是致力于分享编程知识、经验和技巧、以及记录我的学习旅程。","date":"2023-10-18T04:48:31.426Z","updated":"2023-10-18T04:48:31.426Z","path":"about.html","title":"","comments":1,"layout":"page","_id":"clqhfxjqe0000jkgldgzj2vt4","content":"<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>欢迎来到我的编程笔记博客！这里是致力于分享编程知识、经验和技巧、以及记录我的学习旅程。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h1><p>欢迎来到我的编程笔记博客！这里是致力于分享编程知识、经验和技巧、以及记录我的学习旅程。</p>\n"}],"Post":[{"title":"Git常见错误","date":"2023-12-23T02:00:00.000Z","_content":"\n\n#### Failed to connect to github.com port 443 after ***** ms: Couldn‘t connect to server\n> 解决方法:设置---网络和Internet---代理---地址:端口  \n\n![Alt text](../../Img/2023122311111.png)\n修改git配置:\n{% codeblock lang:go %}\ngit config --global http.proxy http://127.0.0.1:4780\ngit config --global https.proxy http://127.0.0.1:4780\n{% endcodeblock %}\n","source":"_posts/10.其他/Git常见错误.md","raw":"---\ntitle: Git常见错误\ndate: 2023-12-23 10:00:00\ncategories: Git常见错误\ntags: \n- Git\n- 错误\n---\n\n\n#### Failed to connect to github.com port 443 after ***** ms: Couldn‘t connect to server\n> 解决方法:设置---网络和Internet---代理---地址:端口  \n\n![Alt text](../../Img/2023122311111.png)\n修改git配置:\n{% codeblock lang:go %}\ngit config --global http.proxy http://127.0.0.1:4780\ngit config --global https.proxy http://127.0.0.1:4780\n{% endcodeblock %}\n","slug":"10.其他/Git常见错误","published":1,"updated":"2023-12-23T02:27:27.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqg0001jkgldzrq0024","content":"<h4 id=\"Failed-to-connect-to-github-com-port-443-after-ms-Couldn‘t-connect-to-server\"><a href=\"#Failed-to-connect-to-github-com-port-443-after-ms-Couldn‘t-connect-to-server\" class=\"headerlink\" title=\"Failed to connect to github.com port 443 after ***** ms: Couldn‘t connect to server\"></a>Failed to connect to github.com port 443 after ***** ms: Couldn‘t connect to server</h4><blockquote>\n<p>解决方法:设置—网络和Internet—代理—地址:端口  </p>\n</blockquote>\n<p><img src=\"/../../Img/2023122311111.png\" alt=\"Alt text\"><br>修改git配置:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global http.proxy http:<span class=\"comment\">//127.0.0.1:4780</span></span><br><span class=\"line\">git config --global https.proxy http:<span class=\"comment\">//127.0.0.1:4780</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"Failed-to-connect-to-github-com-port-443-after-ms-Couldn‘t-connect-to-server\"><a href=\"#Failed-to-connect-to-github-com-port-443-after-ms-Couldn‘t-connect-to-server\" class=\"headerlink\" title=\"Failed to connect to github.com port 443 after ***** ms: Couldn‘t connect to server\"></a>Failed to connect to github.com port 443 after ***** ms: Couldn‘t connect to server</h4><blockquote>\n<p>解决方法:设置—网络和Internet—代理—地址:端口  </p>\n</blockquote>\n<p><img src=\"/../../Img/2023122311111.png\" alt=\"Alt text\"><br>修改git配置:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global http.proxy http:<span class=\"comment\">//127.0.0.1:4780</span></span><br><span class=\"line\">git config --global https.proxy http:<span class=\"comment\">//127.0.0.1:4780</span></span><br></pre></td></tr></table></figure>\n"},{"title":"常用工具集合","date":"2022-02-12T11:00:40.000Z","_content":"# 常用工具集合\n## 集成开发环境 (IDEs)\n- Visual Studio \n\n## 文本编辑器\n- Visual Studio Code\n- Sublime Text\n\n## 学习记录\n我常用的记录笔记的方法。\n- **Markdown**\nMarkdown是一种轻量级标记语言，通常被程序员、写作者和博客作者用来编写格式简单的文档，如博客文章、文档、笔记等再加上Hexo可以轻松发布静态网站,使用vs code编写。\n- **PlantUML**\nPlantUML是一个开源的文本到UML图形转换工具，它允许您使用简单的文本描述来创建各种UML（Unified Modeling Language）图表，如时序图、类图、用例图、活动图等,使用vs code编写,需要安装PlantUML扩展。\n\n## 工具 \n- Pandoc \nPandoc是一个开源的文档转换工具，它可以将一种格式的文档转换为另一种格式，比如将Markdown转换为HTML或PDF，或者将Docx转换为Markdown。Pandoc支持多种输入和输出格式，并且可以通过命令行或API进行操作。它是一个非常强大和灵活的工具，被广泛用于文档处理和格式转换领域。\n- Hexo\nHexo是一个基于Node.js的静态博客框架，它使用Markdown作为写作语言，并支持许多插件和主题，可以轻松地部署到Github Pages或Coding Pages。Hexo具有强大的插件系统，可以轻松地扩展功能，\n- FFmpeg\nFFmpeg是一个跨平台的开源视频和音频转换工具，支持多种格式转换，如将MP4转换为AVI、将MP4转换为GIF、将MP4转换为MKV等。","source":"_posts/10.其他/常用工具集合.md","raw":"---\ntitle: 常用工具集合\ndate: 2022-02-12 19:00:40\ncategories: 工具\ntags: \n- 工具\n---\n# 常用工具集合\n## 集成开发环境 (IDEs)\n- Visual Studio \n\n## 文本编辑器\n- Visual Studio Code\n- Sublime Text\n\n## 学习记录\n我常用的记录笔记的方法。\n- **Markdown**\nMarkdown是一种轻量级标记语言，通常被程序员、写作者和博客作者用来编写格式简单的文档，如博客文章、文档、笔记等再加上Hexo可以轻松发布静态网站,使用vs code编写。\n- **PlantUML**\nPlantUML是一个开源的文本到UML图形转换工具，它允许您使用简单的文本描述来创建各种UML（Unified Modeling Language）图表，如时序图、类图、用例图、活动图等,使用vs code编写,需要安装PlantUML扩展。\n\n## 工具 \n- Pandoc \nPandoc是一个开源的文档转换工具，它可以将一种格式的文档转换为另一种格式，比如将Markdown转换为HTML或PDF，或者将Docx转换为Markdown。Pandoc支持多种输入和输出格式，并且可以通过命令行或API进行操作。它是一个非常强大和灵活的工具，被广泛用于文档处理和格式转换领域。\n- Hexo\nHexo是一个基于Node.js的静态博客框架，它使用Markdown作为写作语言，并支持许多插件和主题，可以轻松地部署到Github Pages或Coding Pages。Hexo具有强大的插件系统，可以轻松地扩展功能，\n- FFmpeg\nFFmpeg是一个跨平台的开源视频和音频转换工具，支持多种格式转换，如将MP4转换为AVI、将MP4转换为GIF、将MP4转换为MKV等。","slug":"10.其他/常用工具集合","published":1,"updated":"2023-12-18T03:15:29.271Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqj0002jkglh47ma4n2","content":"<h1 id=\"常用工具集合\"><a href=\"#常用工具集合\" class=\"headerlink\" title=\"常用工具集合\"></a>常用工具集合</h1><h2 id=\"集成开发环境-IDEs\"><a href=\"#集成开发环境-IDEs\" class=\"headerlink\" title=\"集成开发环境 (IDEs)\"></a>集成开发环境 (IDEs)</h2><ul>\n<li>Visual Studio</li>\n</ul>\n<h2 id=\"文本编辑器\"><a href=\"#文本编辑器\" class=\"headerlink\" title=\"文本编辑器\"></a>文本编辑器</h2><ul>\n<li>Visual Studio Code</li>\n<li>Sublime Text</li>\n</ul>\n<h2 id=\"学习记录\"><a href=\"#学习记录\" class=\"headerlink\" title=\"学习记录\"></a>学习记录</h2><p>我常用的记录笔记的方法。</p>\n<ul>\n<li><strong>Markdown</strong><br>Markdown是一种轻量级标记语言，通常被程序员、写作者和博客作者用来编写格式简单的文档，如博客文章、文档、笔记等再加上Hexo可以轻松发布静态网站,使用vs code编写。</li>\n<li><strong>PlantUML</strong><br>PlantUML是一个开源的文本到UML图形转换工具，它允许您使用简单的文本描述来创建各种UML（Unified Modeling Language）图表，如时序图、类图、用例图、活动图等,使用vs code编写,需要安装PlantUML扩展。</li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li>Pandoc<br>Pandoc是一个开源的文档转换工具，它可以将一种格式的文档转换为另一种格式，比如将Markdown转换为HTML或PDF，或者将Docx转换为Markdown。Pandoc支持多种输入和输出格式，并且可以通过命令行或API进行操作。它是一个非常强大和灵活的工具，被广泛用于文档处理和格式转换领域。</li>\n<li>Hexo<br>Hexo是一个基于Node.js的静态博客框架，它使用Markdown作为写作语言，并支持许多插件和主题，可以轻松地部署到Github Pages或Coding Pages。Hexo具有强大的插件系统，可以轻松地扩展功能，</li>\n<li>FFmpeg<br>FFmpeg是一个跨平台的开源视频和音频转换工具，支持多种格式转换，如将MP4转换为AVI、将MP4转换为GIF、将MP4转换为MKV等。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"常用工具集合\"><a href=\"#常用工具集合\" class=\"headerlink\" title=\"常用工具集合\"></a>常用工具集合</h1><h2 id=\"集成开发环境-IDEs\"><a href=\"#集成开发环境-IDEs\" class=\"headerlink\" title=\"集成开发环境 (IDEs)\"></a>集成开发环境 (IDEs)</h2><ul>\n<li>Visual Studio</li>\n</ul>\n<h2 id=\"文本编辑器\"><a href=\"#文本编辑器\" class=\"headerlink\" title=\"文本编辑器\"></a>文本编辑器</h2><ul>\n<li>Visual Studio Code</li>\n<li>Sublime Text</li>\n</ul>\n<h2 id=\"学习记录\"><a href=\"#学习记录\" class=\"headerlink\" title=\"学习记录\"></a>学习记录</h2><p>我常用的记录笔记的方法。</p>\n<ul>\n<li><strong>Markdown</strong><br>Markdown是一种轻量级标记语言，通常被程序员、写作者和博客作者用来编写格式简单的文档，如博客文章、文档、笔记等再加上Hexo可以轻松发布静态网站,使用vs code编写。</li>\n<li><strong>PlantUML</strong><br>PlantUML是一个开源的文本到UML图形转换工具，它允许您使用简单的文本描述来创建各种UML（Unified Modeling Language）图表，如时序图、类图、用例图、活动图等,使用vs code编写,需要安装PlantUML扩展。</li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li>Pandoc<br>Pandoc是一个开源的文档转换工具，它可以将一种格式的文档转换为另一种格式，比如将Markdown转换为HTML或PDF，或者将Docx转换为Markdown。Pandoc支持多种输入和输出格式，并且可以通过命令行或API进行操作。它是一个非常强大和灵活的工具，被广泛用于文档处理和格式转换领域。</li>\n<li>Hexo<br>Hexo是一个基于Node.js的静态博客框架，它使用Markdown作为写作语言，并支持许多插件和主题，可以轻松地部署到Github Pages或Coding Pages。Hexo具有强大的插件系统，可以轻松地扩展功能，</li>\n<li>FFmpeg<br>FFmpeg是一个跨平台的开源视频和音频转换工具，支持多种格式转换，如将MP4转换为AVI、将MP4转换为GIF、将MP4转换为MKV等。</li>\n</ul>\n"},{"title":"Go第二天结构和基础命令和语法","date":"2023-11-26T02:22:39.000Z","_content":"# **包的概念**\n在go语言中包(package)是组织代码的基本单元，用于关联功能在一起，类似C#命名空间（仅次于类似）**一个包可以包含多个源文件**，但这些文件必须要在同一个目录下，并且包名必须相同，每个Go源文件的开头都需要声明所属的包。  \n- 包声明在每个go源文件的开头，都需要声明该文件所属的包名\n{% codeblock lang:go %}\npackage main // 声明该文件所属main包\n{% endcodeblock %}\n- 包的访问权限 Go中的标识符变量或函数名，可以是导出或非导出的。\n**导出(大写字母开头，类似C#的public)**\n**非导出（小写字母开头，类似C#的private）**\n## **入口包**\n**main包**：go程序执行入口是**main**包中的“func main()”函数，只有main包可以包含 “func main()”函数。执行程序从这个函数开始。\n\n# **init与main**\n## init函数\nInit函数是一个特殊的函数，用于在程序运行时候自动执行初始化操作，这个函数在程序开始执行调用，不能显示调用。\n- 程序执行前做包的初始化，初始化包的变量\n- 一个包可以拥有多个init函数。\n- 对于同一个包（同一个源文件或多个源文件组成的包），init() 函数会按照它们在源文件中的编写顺序依次被调用，多个源文件组成一个包，这些文件中的init函数按照文件名排序执行（ASCII字符排序）。\n- ini函数不能被其他函数调用，而是在main函数之前，自动被调用\n## main函数\n**Go语言的默认主函数**\n{% codeblock lang:go %}\nfunc main(){\n\n    //函数体\n}\n\n{% endcodeblock %}\n## init函数和main函数的异同\n### 相同点\n> 两个函数在定义是不能有任何参数和返回值，都是go程序自动调用。  \n### 不同\n> **init可以应用任何包中，可以重复定义多个**。  \n\n> **main函数只能用于main包中，只能定义一个**。\n\n# **了解一下go的命令**\n输入go之后查看go相关命令（在已经安装的golang环境）\n> \ngo\nGo是一个管理Go源代码的工具。\n\n命令用法：\n\n        go <command> [arguments]\n\n基本command命令:\n\n        bug        启动错误报告\n        build      编译包和依赖项\n        clean      删除对象文件和缓存文件\n        doc        显示包装或符号的文档\n        env        打印Go环境信息\n        fix        更新包以使用新的API\n        fmt        gofmt（重新格式化）包源\n        generate   通过处理源生成Go文件\n        get        将依赖项添加到当前模块并安装them\n        install    编译和安装包和依赖项\n        list       列出包或模块\n        mod        模块维护\n        work       工作空间维护\n        run        编译并运行Go程序\n        test       测试包\n        tool       运行指定的go工具\n        version    打印Go版本\n        vet        报告包中可能出现的错误\n\n有关命令的详细信息，请使用“go help＜command＞”。\n\n其他帮助主题:\n\n        buildconstraint 生成约束\n        buildmode       构建模式\n        c               在Go和C之间调用\n        cache           构建和测试缓存\n        environment     环境变量\n        filetype        文件类型\n        go.mod          go.mod文件\n        gopath          GOPATH环境变量\n        gopath-get      传统GOPATH go get\n        goproxy         模块代理协议\n        importpath      导入路径语法\n        modules         模块、模块版本等\n        module-get      模块感知go get\n        module-auth     使用go.sum的模块身份验证\n        packages        程序包列表和模式\n        private         下载非公共代码的配置\n        testflag        测试标志\n        testfunc        测试功能\n        vcs             用GOVCS控制版本控制\n\n\n\n{% codeblock lang:go %}\npackage mypackage\n\nvar PublicVar int = 10 // 首字母大写的变量，公开的，可以被其他包导入和使用\n\nvar privateVar int = 20 // 首字母小写的变量，私有的，只能在当前包内部使用\n\nfunc PublicFunc() {\n    // 这是一个公开的函数，可以被其他包调用\n}\n\nfunc privateFunc() {\n    // 这是一个私有的函数，只能在当前包内部使用\n}\n{% endcodeblock %}\n# 基本语法\n## **运算符与其他语言相似**\n\n|       运算符    &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;   |          描述        &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;  |\n|----|-------------------------------------------------|\n| +  | 相加 |\n| -  | 相减 |\n| /  | 相除 |\n| %  | 求余 |\n\n## **关系运算符**\n\n|       运算符    &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;   |          描述        &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;  |\n|----|-------------------------------------------------|\n| ==  | 检查两个值是否相等，相等True否则返回False |\n| !=  | 检查两个值是否不想等，如果不想等返回True否则返回False |\n| >  | 检查左边值是否大于右边值，如果是返回True否则返回False |\n| >=  | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False |\n| <  | 检查左边值是否小于右边值，如果是返回 True 否则返回 False |\n| <=  | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False |\n\n## **逻辑运算符**\n| 运算符 |描述|\n|----|-----|\n|&&| 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False|\n| \\|\\| | 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False|\n|&&| 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True |\n\n## 下划线\n“_”下划线是一个特殊标识符，通常作用于占位符和忽略丢弃变量。\n\n- 下划线在import中， **import _ 包路径** 只是用来引用包，仅仅是为了调用init()函数。无法通过包名调用包中的其他函数。\n- 下划线在代码中可以表示不需要使用的变量(声明了一个变量但未在后续代码中使用，编译器会提示未使用的变量，并在编译时报错,为了避免这种错误，可以选择使用下划线 _ 来表示这个变量是不使用的)。\n## 变量\n变量也是与其他语言大差不差，但是声明和使用有所区别。\n- **变量声明:** go语言中的变量需要声明之后才能使用，同一个作用于不支持重复声明，**并且变量声明后必须使用**，*否则报错a declared and not used*。\n**变量声明为：** \n{% codeblock lang:go %}\nvar 变量名 变量类型\n\n//基本的变量声明：\nvar x int // 声明一个变量名为 x，类型为 int，初始值为该类型的零值（0）\n\n//同时声明多个变量\nvar a, b, c int // 声明多个同类型的变量\nvar name, age = \"Alice\", 30 // 初始化同时声明多个变量\n\nvar number int // 声明一个变量名为 number，类型为 int，初始值为 0（int 类型的零值）\nvar isEnabled bool // 声明一个变量名为 isEnabled，类型为 bool，初始值为 false（bool 类型的零值）\n\n//短变量声明（:=）,使用短变量声明可以在函数内部声明并初始化变量，而不需要使用 var 关键字\nx := 10 // 声明并初始化一个整型变量 x，类型由编译器自动推断为 int\nname, age := \"Bob\", 25 // 同时声明并初始化多个变量\n\n\n{% endcodeblock %}\n","source":"_posts/1.计算机编程/Go第二天.md","raw":"---\ntitle: Go第二天结构和基础命令和语法\ndate: 2023-11-26 10:22:39\ntags:\n- GoLang\n---\n# **包的概念**\n在go语言中包(package)是组织代码的基本单元，用于关联功能在一起，类似C#命名空间（仅次于类似）**一个包可以包含多个源文件**，但这些文件必须要在同一个目录下，并且包名必须相同，每个Go源文件的开头都需要声明所属的包。  \n- 包声明在每个go源文件的开头，都需要声明该文件所属的包名\n{% codeblock lang:go %}\npackage main // 声明该文件所属main包\n{% endcodeblock %}\n- 包的访问权限 Go中的标识符变量或函数名，可以是导出或非导出的。\n**导出(大写字母开头，类似C#的public)**\n**非导出（小写字母开头，类似C#的private）**\n## **入口包**\n**main包**：go程序执行入口是**main**包中的“func main()”函数，只有main包可以包含 “func main()”函数。执行程序从这个函数开始。\n\n# **init与main**\n## init函数\nInit函数是一个特殊的函数，用于在程序运行时候自动执行初始化操作，这个函数在程序开始执行调用，不能显示调用。\n- 程序执行前做包的初始化，初始化包的变量\n- 一个包可以拥有多个init函数。\n- 对于同一个包（同一个源文件或多个源文件组成的包），init() 函数会按照它们在源文件中的编写顺序依次被调用，多个源文件组成一个包，这些文件中的init函数按照文件名排序执行（ASCII字符排序）。\n- ini函数不能被其他函数调用，而是在main函数之前，自动被调用\n## main函数\n**Go语言的默认主函数**\n{% codeblock lang:go %}\nfunc main(){\n\n    //函数体\n}\n\n{% endcodeblock %}\n## init函数和main函数的异同\n### 相同点\n> 两个函数在定义是不能有任何参数和返回值，都是go程序自动调用。  \n### 不同\n> **init可以应用任何包中，可以重复定义多个**。  \n\n> **main函数只能用于main包中，只能定义一个**。\n\n# **了解一下go的命令**\n输入go之后查看go相关命令（在已经安装的golang环境）\n> \ngo\nGo是一个管理Go源代码的工具。\n\n命令用法：\n\n        go <command> [arguments]\n\n基本command命令:\n\n        bug        启动错误报告\n        build      编译包和依赖项\n        clean      删除对象文件和缓存文件\n        doc        显示包装或符号的文档\n        env        打印Go环境信息\n        fix        更新包以使用新的API\n        fmt        gofmt（重新格式化）包源\n        generate   通过处理源生成Go文件\n        get        将依赖项添加到当前模块并安装them\n        install    编译和安装包和依赖项\n        list       列出包或模块\n        mod        模块维护\n        work       工作空间维护\n        run        编译并运行Go程序\n        test       测试包\n        tool       运行指定的go工具\n        version    打印Go版本\n        vet        报告包中可能出现的错误\n\n有关命令的详细信息，请使用“go help＜command＞”。\n\n其他帮助主题:\n\n        buildconstraint 生成约束\n        buildmode       构建模式\n        c               在Go和C之间调用\n        cache           构建和测试缓存\n        environment     环境变量\n        filetype        文件类型\n        go.mod          go.mod文件\n        gopath          GOPATH环境变量\n        gopath-get      传统GOPATH go get\n        goproxy         模块代理协议\n        importpath      导入路径语法\n        modules         模块、模块版本等\n        module-get      模块感知go get\n        module-auth     使用go.sum的模块身份验证\n        packages        程序包列表和模式\n        private         下载非公共代码的配置\n        testflag        测试标志\n        testfunc        测试功能\n        vcs             用GOVCS控制版本控制\n\n\n\n{% codeblock lang:go %}\npackage mypackage\n\nvar PublicVar int = 10 // 首字母大写的变量，公开的，可以被其他包导入和使用\n\nvar privateVar int = 20 // 首字母小写的变量，私有的，只能在当前包内部使用\n\nfunc PublicFunc() {\n    // 这是一个公开的函数，可以被其他包调用\n}\n\nfunc privateFunc() {\n    // 这是一个私有的函数，只能在当前包内部使用\n}\n{% endcodeblock %}\n# 基本语法\n## **运算符与其他语言相似**\n\n|       运算符    &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;   |          描述        &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;  |\n|----|-------------------------------------------------|\n| +  | 相加 |\n| -  | 相减 |\n| /  | 相除 |\n| %  | 求余 |\n\n## **关系运算符**\n\n|       运算符    &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;   |          描述        &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;  |\n|----|-------------------------------------------------|\n| ==  | 检查两个值是否相等，相等True否则返回False |\n| !=  | 检查两个值是否不想等，如果不想等返回True否则返回False |\n| >  | 检查左边值是否大于右边值，如果是返回True否则返回False |\n| >=  | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False |\n| <  | 检查左边值是否小于右边值，如果是返回 True 否则返回 False |\n| <=  | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False |\n\n## **逻辑运算符**\n| 运算符 |描述|\n|----|-----|\n|&&| 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False|\n| \\|\\| | 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False|\n|&&| 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True |\n\n## 下划线\n“_”下划线是一个特殊标识符，通常作用于占位符和忽略丢弃变量。\n\n- 下划线在import中， **import _ 包路径** 只是用来引用包，仅仅是为了调用init()函数。无法通过包名调用包中的其他函数。\n- 下划线在代码中可以表示不需要使用的变量(声明了一个变量但未在后续代码中使用，编译器会提示未使用的变量，并在编译时报错,为了避免这种错误，可以选择使用下划线 _ 来表示这个变量是不使用的)。\n## 变量\n变量也是与其他语言大差不差，但是声明和使用有所区别。\n- **变量声明:** go语言中的变量需要声明之后才能使用，同一个作用于不支持重复声明，**并且变量声明后必须使用**，*否则报错a declared and not used*。\n**变量声明为：** \n{% codeblock lang:go %}\nvar 变量名 变量类型\n\n//基本的变量声明：\nvar x int // 声明一个变量名为 x，类型为 int，初始值为该类型的零值（0）\n\n//同时声明多个变量\nvar a, b, c int // 声明多个同类型的变量\nvar name, age = \"Alice\", 30 // 初始化同时声明多个变量\n\nvar number int // 声明一个变量名为 number，类型为 int，初始值为 0（int 类型的零值）\nvar isEnabled bool // 声明一个变量名为 isEnabled，类型为 bool，初始值为 false（bool 类型的零值）\n\n//短变量声明（:=）,使用短变量声明可以在函数内部声明并初始化变量，而不需要使用 var 关键字\nx := 10 // 声明并初始化一个整型变量 x，类型由编译器自动推断为 int\nname, age := \"Bob\", 25 // 同时声明并初始化多个变量\n\n\n{% endcodeblock %}\n","slug":"1.计算机编程/Go第二天","published":1,"updated":"2023-12-02T05:37:15.343Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjql0005jkglbirefv75","content":"<h1 id=\"包的概念\"><a href=\"#包的概念\" class=\"headerlink\" title=\"包的概念\"></a><strong>包的概念</strong></h1><p>在go语言中包(package)是组织代码的基本单元，用于关联功能在一起，类似C#命名空间（仅次于类似）<strong>一个包可以包含多个源文件</strong>，但这些文件必须要在同一个目录下，并且包名必须相同，每个Go源文件的开头都需要声明所属的包。  </p>\n<ul>\n<li>包声明在每个go源文件的开头，都需要声明该文件所属的包名<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main <span class=\"comment\">// 声明该文件所属main包</span></span><br></pre></td></tr></table></figure></li>\n<li>包的访问权限 Go中的标识符变量或函数名，可以是导出或非导出的。<br><strong>导出(大写字母开头，类似C#的public)</strong><br><strong>非导出（小写字母开头，类似C#的private）</strong></li>\n</ul>\n<h2 id=\"入口包\"><a href=\"#入口包\" class=\"headerlink\" title=\"入口包\"></a><strong>入口包</strong></h2><p><strong>main包</strong>：go程序执行入口是<strong>main</strong>包中的“func main()”函数，只有main包可以包含 “func main()”函数。执行程序从这个函数开始。</p>\n<h1 id=\"init与main\"><a href=\"#init与main\" class=\"headerlink\" title=\"init与main\"></a><strong>init与main</strong></h1><h2 id=\"init函数\"><a href=\"#init函数\" class=\"headerlink\" title=\"init函数\"></a>init函数</h2><p>Init函数是一个特殊的函数，用于在程序运行时候自动执行初始化操作，这个函数在程序开始执行调用，不能显示调用。</p>\n<ul>\n<li>程序执行前做包的初始化，初始化包的变量</li>\n<li>一个包可以拥有多个init函数。</li>\n<li>对于同一个包（同一个源文件或多个源文件组成的包），init() 函数会按照它们在源文件中的编写顺序依次被调用，多个源文件组成一个包，这些文件中的init函数按照文件名排序执行（ASCII字符排序）。</li>\n<li>ini函数不能被其他函数调用，而是在main函数之前，自动被调用</li>\n</ul>\n<h2 id=\"main函数\"><a href=\"#main函数\" class=\"headerlink\" title=\"main函数\"></a>main函数</h2><p><strong>Go语言的默认主函数</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//函数体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"init函数和main函数的异同\"><a href=\"#init函数和main函数的异同\" class=\"headerlink\" title=\"init函数和main函数的异同\"></a>init函数和main函数的异同</h2><h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h3><blockquote>\n<p>两个函数在定义是不能有任何参数和返回值，都是go程序自动调用。  </p>\n</blockquote>\n<h3 id=\"不同\"><a href=\"#不同\" class=\"headerlink\" title=\"不同\"></a>不同</h3><blockquote>\n<p><strong>init可以应用任何包中，可以重复定义多个</strong>。  </p>\n</blockquote>\n<blockquote>\n<p><strong>main函数只能用于main包中，只能定义一个</strong>。</p>\n</blockquote>\n<h1 id=\"了解一下go的命令\"><a href=\"#了解一下go的命令\" class=\"headerlink\" title=\"了解一下go的命令\"></a><strong>了解一下go的命令</strong></h1><p>输入go之后查看go相关命令（在已经安装的golang环境）</p>\n<blockquote>\n</blockquote>\n<p>go<br>Go是一个管理Go源代码的工具。</p>\n<p>命令用法：</p>\n<pre><code>    go &lt;command&gt; [arguments]\n</code></pre>\n<p>基本command命令:</p>\n<pre><code>    bug        启动错误报告\n    build      编译包和依赖项\n    clean      删除对象文件和缓存文件\n    doc        显示包装或符号的文档\n    env        打印Go环境信息\n    fix        更新包以使用新的API\n    fmt        gofmt（重新格式化）包源\n    generate   通过处理源生成Go文件\n    get        将依赖项添加到当前模块并安装them\n    install    编译和安装包和依赖项\n    list       列出包或模块\n    mod        模块维护\n    work       工作空间维护\n    run        编译并运行Go程序\n    test       测试包\n    tool       运行指定的go工具\n    version    打印Go版本\n    vet        报告包中可能出现的错误\n</code></pre>\n<p>有关命令的详细信息，请使用“go help＜command＞”。</p>\n<p>其他帮助主题:</p>\n<pre><code>    buildconstraint 生成约束\n    buildmode       构建模式\n    c               在Go和C之间调用\n    cache           构建和测试缓存\n    environment     环境变量\n    filetype        文件类型\n    go.mod          go.mod文件\n    gopath          GOPATH环境变量\n    gopath-get      传统GOPATH go get\n    goproxy         模块代理协议\n    importpath      导入路径语法\n    modules         模块、模块版本等\n    module-get      模块感知go get\n    module-auth     使用go.sum的模块身份验证\n    packages        程序包列表和模式\n    private         下载非公共代码的配置\n    testflag        测试标志\n    testfunc        测试功能\n    vcs             用GOVCS控制版本控制\n</code></pre>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> mypackage</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> PublicVar <span class=\"type\">int</span> = <span class=\"number\">10</span> <span class=\"comment\">// 首字母大写的变量，公开的，可以被其他包导入和使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> privateVar <span class=\"type\">int</span> = <span class=\"number\">20</span> <span class=\"comment\">// 首字母小写的变量，私有的，只能在当前包内部使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">PublicFunc</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这是一个公开的函数，可以被其他包调用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">privateFunc</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这是一个私有的函数，只能在当前包内部使用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h1><h2 id=\"运算符与其他语言相似\"><a href=\"#运算符与其他语言相似\" class=\"headerlink\" title=\"运算符与其他语言相似\"></a><strong>运算符与其他语言相似</strong></h2><table>\n<thead>\n<tr>\n<th>运算符    &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</th>\n<th>描述        &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>相加</td>\n</tr>\n<tr>\n<td>-</td>\n<td>相减</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td>相除</td>\n</tr>\n<tr>\n<td>%</td>\n<td>求余</td>\n</tr>\n</tbody></table>\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a><strong>关系运算符</strong></h2><table>\n<thead>\n<tr>\n<th>运算符    &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</th>\n<th>描述        &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x3D;&#x3D;</td>\n<td>检查两个值是否相等，相等True否则返回False</td>\n</tr>\n<tr>\n<td>!&#x3D;</td>\n<td>检查两个值是否不想等，如果不想等返回True否则返回False</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>检查左边值是否大于右边值，如果是返回True否则返回False</td>\n</tr>\n<tr>\n<td>&gt;&#x3D;</td>\n<td>检查左边值是否大于等于右边值，如果是返回 True 否则返回 False</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>检查左边值是否小于右边值，如果是返回 True 否则返回 False</td>\n</tr>\n<tr>\n<td>&lt;&#x3D;</td>\n<td>检查左边值是否小于等于右边值，如果是返回 True 否则返回 False</td>\n</tr>\n</tbody></table>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a><strong>逻辑运算符</strong></h2><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;&amp;</td>\n<td>逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False</td>\n</tr>\n<tr>\n<td>||</td>\n<td>逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True</td>\n</tr>\n</tbody></table>\n<h2 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线\"></a>下划线</h2><p>“_”下划线是一个特殊标识符，通常作用于占位符和忽略丢弃变量。</p>\n<ul>\n<li>下划线在import中， <strong>import _ 包路径</strong> 只是用来引用包，仅仅是为了调用init()函数。无法通过包名调用包中的其他函数。</li>\n<li>下划线在代码中可以表示不需要使用的变量(声明了一个变量但未在后续代码中使用，编译器会提示未使用的变量，并在编译时报错,为了避免这种错误，可以选择使用下划线 _ 来表示这个变量是不使用的)。</li>\n</ul>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>变量也是与其他语言大差不差，但是声明和使用有所区别。</p>\n<ul>\n<li><strong>变量声明:</strong> go语言中的变量需要声明之后才能使用，同一个作用于不支持重复声明，<strong>并且变量声明后必须使用</strong>，<em>否则报错a declared and not used</em>。<br><strong>变量声明为：</strong> <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> 变量名 变量类型</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//基本的变量声明：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"type\">int</span> <span class=\"comment\">// 声明一个变量名为 x，类型为 int，初始值为该类型的零值（0）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同时声明多个变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a, b, c <span class=\"type\">int</span> <span class=\"comment\">// 声明多个同类型的变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name, age = <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"number\">30</span> <span class=\"comment\">// 初始化同时声明多个变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> number <span class=\"type\">int</span> <span class=\"comment\">// 声明一个变量名为 number，类型为 int，初始值为 0（int 类型的零值）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isEnabled <span class=\"type\">bool</span> <span class=\"comment\">// 声明一个变量名为 isEnabled，类型为 bool，初始值为 false（bool 类型的零值）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//短变量声明（:=）,使用短变量声明可以在函数内部声明并初始化变量，而不需要使用 var 关键字</span></span><br><span class=\"line\">x := <span class=\"number\">10</span> <span class=\"comment\">// 声明并初始化一个整型变量 x，类型由编译器自动推断为 int</span></span><br><span class=\"line\">name, age := <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"number\">25</span> <span class=\"comment\">// 同时声明并初始化多个变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"包的概念\"><a href=\"#包的概念\" class=\"headerlink\" title=\"包的概念\"></a><strong>包的概念</strong></h1><p>在go语言中包(package)是组织代码的基本单元，用于关联功能在一起，类似C#命名空间（仅次于类似）<strong>一个包可以包含多个源文件</strong>，但这些文件必须要在同一个目录下，并且包名必须相同，每个Go源文件的开头都需要声明所属的包。  </p>\n<ul>\n<li>包声明在每个go源文件的开头，都需要声明该文件所属的包名<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main <span class=\"comment\">// 声明该文件所属main包</span></span><br></pre></td></tr></table></figure></li>\n<li>包的访问权限 Go中的标识符变量或函数名，可以是导出或非导出的。<br><strong>导出(大写字母开头，类似C#的public)</strong><br><strong>非导出（小写字母开头，类似C#的private）</strong></li>\n</ul>\n<h2 id=\"入口包\"><a href=\"#入口包\" class=\"headerlink\" title=\"入口包\"></a><strong>入口包</strong></h2><p><strong>main包</strong>：go程序执行入口是<strong>main</strong>包中的“func main()”函数，只有main包可以包含 “func main()”函数。执行程序从这个函数开始。</p>\n<h1 id=\"init与main\"><a href=\"#init与main\" class=\"headerlink\" title=\"init与main\"></a><strong>init与main</strong></h1><h2 id=\"init函数\"><a href=\"#init函数\" class=\"headerlink\" title=\"init函数\"></a>init函数</h2><p>Init函数是一个特殊的函数，用于在程序运行时候自动执行初始化操作，这个函数在程序开始执行调用，不能显示调用。</p>\n<ul>\n<li>程序执行前做包的初始化，初始化包的变量</li>\n<li>一个包可以拥有多个init函数。</li>\n<li>对于同一个包（同一个源文件或多个源文件组成的包），init() 函数会按照它们在源文件中的编写顺序依次被调用，多个源文件组成一个包，这些文件中的init函数按照文件名排序执行（ASCII字符排序）。</li>\n<li>ini函数不能被其他函数调用，而是在main函数之前，自动被调用</li>\n</ul>\n<h2 id=\"main函数\"><a href=\"#main函数\" class=\"headerlink\" title=\"main函数\"></a>main函数</h2><p><strong>Go语言的默认主函数</strong></p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//函数体</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"init函数和main函数的异同\"><a href=\"#init函数和main函数的异同\" class=\"headerlink\" title=\"init函数和main函数的异同\"></a>init函数和main函数的异同</h2><h3 id=\"相同点\"><a href=\"#相同点\" class=\"headerlink\" title=\"相同点\"></a>相同点</h3><blockquote>\n<p>两个函数在定义是不能有任何参数和返回值，都是go程序自动调用。  </p>\n</blockquote>\n<h3 id=\"不同\"><a href=\"#不同\" class=\"headerlink\" title=\"不同\"></a>不同</h3><blockquote>\n<p><strong>init可以应用任何包中，可以重复定义多个</strong>。  </p>\n</blockquote>\n<blockquote>\n<p><strong>main函数只能用于main包中，只能定义一个</strong>。</p>\n</blockquote>\n<h1 id=\"了解一下go的命令\"><a href=\"#了解一下go的命令\" class=\"headerlink\" title=\"了解一下go的命令\"></a><strong>了解一下go的命令</strong></h1><p>输入go之后查看go相关命令（在已经安装的golang环境）</p>\n<blockquote>\n</blockquote>\n<p>go<br>Go是一个管理Go源代码的工具。</p>\n<p>命令用法：</p>\n<pre><code>    go &lt;command&gt; [arguments]\n</code></pre>\n<p>基本command命令:</p>\n<pre><code>    bug        启动错误报告\n    build      编译包和依赖项\n    clean      删除对象文件和缓存文件\n    doc        显示包装或符号的文档\n    env        打印Go环境信息\n    fix        更新包以使用新的API\n    fmt        gofmt（重新格式化）包源\n    generate   通过处理源生成Go文件\n    get        将依赖项添加到当前模块并安装them\n    install    编译和安装包和依赖项\n    list       列出包或模块\n    mod        模块维护\n    work       工作空间维护\n    run        编译并运行Go程序\n    test       测试包\n    tool       运行指定的go工具\n    version    打印Go版本\n    vet        报告包中可能出现的错误\n</code></pre>\n<p>有关命令的详细信息，请使用“go help＜command＞”。</p>\n<p>其他帮助主题:</p>\n<pre><code>    buildconstraint 生成约束\n    buildmode       构建模式\n    c               在Go和C之间调用\n    cache           构建和测试缓存\n    environment     环境变量\n    filetype        文件类型\n    go.mod          go.mod文件\n    gopath          GOPATH环境变量\n    gopath-get      传统GOPATH go get\n    goproxy         模块代理协议\n    importpath      导入路径语法\n    modules         模块、模块版本等\n    module-get      模块感知go get\n    module-auth     使用go.sum的模块身份验证\n    packages        程序包列表和模式\n    private         下载非公共代码的配置\n    testflag        测试标志\n    testfunc        测试功能\n    vcs             用GOVCS控制版本控制\n</code></pre>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> mypackage</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> PublicVar <span class=\"type\">int</span> = <span class=\"number\">10</span> <span class=\"comment\">// 首字母大写的变量，公开的，可以被其他包导入和使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> privateVar <span class=\"type\">int</span> = <span class=\"number\">20</span> <span class=\"comment\">// 首字母小写的变量，私有的，只能在当前包内部使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">PublicFunc</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这是一个公开的函数，可以被其他包调用</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">privateFunc</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这是一个私有的函数，只能在当前包内部使用</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h1><h2 id=\"运算符与其他语言相似\"><a href=\"#运算符与其他语言相似\" class=\"headerlink\" title=\"运算符与其他语言相似\"></a><strong>运算符与其他语言相似</strong></h2><table>\n<thead>\n<tr>\n<th>运算符    &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</th>\n<th>描述        &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>+</td>\n<td>相加</td>\n</tr>\n<tr>\n<td>-</td>\n<td>相减</td>\n</tr>\n<tr>\n<td>&#x2F;</td>\n<td>相除</td>\n</tr>\n<tr>\n<td>%</td>\n<td>求余</td>\n</tr>\n</tbody></table>\n<h2 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a><strong>关系运算符</strong></h2><table>\n<thead>\n<tr>\n<th>运算符    &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</th>\n<th>描述        &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&#x3D;&#x3D;</td>\n<td>检查两个值是否相等，相等True否则返回False</td>\n</tr>\n<tr>\n<td>!&#x3D;</td>\n<td>检查两个值是否不想等，如果不想等返回True否则返回False</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>检查左边值是否大于右边值，如果是返回True否则返回False</td>\n</tr>\n<tr>\n<td>&gt;&#x3D;</td>\n<td>检查左边值是否大于等于右边值，如果是返回 True 否则返回 False</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>检查左边值是否小于右边值，如果是返回 True 否则返回 False</td>\n</tr>\n<tr>\n<td>&lt;&#x3D;</td>\n<td>检查左边值是否小于等于右边值，如果是返回 True 否则返回 False</td>\n</tr>\n</tbody></table>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a><strong>逻辑运算符</strong></h2><table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>&amp;&amp;</td>\n<td>逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False</td>\n</tr>\n<tr>\n<td>||</td>\n<td>逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True</td>\n</tr>\n</tbody></table>\n<h2 id=\"下划线\"><a href=\"#下划线\" class=\"headerlink\" title=\"下划线\"></a>下划线</h2><p>“_”下划线是一个特殊标识符，通常作用于占位符和忽略丢弃变量。</p>\n<ul>\n<li>下划线在import中， <strong>import _ 包路径</strong> 只是用来引用包，仅仅是为了调用init()函数。无法通过包名调用包中的其他函数。</li>\n<li>下划线在代码中可以表示不需要使用的变量(声明了一个变量但未在后续代码中使用，编译器会提示未使用的变量，并在编译时报错,为了避免这种错误，可以选择使用下划线 _ 来表示这个变量是不使用的)。</li>\n</ul>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>变量也是与其他语言大差不差，但是声明和使用有所区别。</p>\n<ul>\n<li><strong>变量声明:</strong> go语言中的变量需要声明之后才能使用，同一个作用于不支持重复声明，<strong>并且变量声明后必须使用</strong>，<em>否则报错a declared and not used</em>。<br><strong>变量声明为：</strong> <figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> 变量名 变量类型</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//基本的变量声明：</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x <span class=\"type\">int</span> <span class=\"comment\">// 声明一个变量名为 x，类型为 int，初始值为该类型的零值（0）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//同时声明多个变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a, b, c <span class=\"type\">int</span> <span class=\"comment\">// 声明多个同类型的变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> name, age = <span class=\"string\">&quot;Alice&quot;</span>, <span class=\"number\">30</span> <span class=\"comment\">// 初始化同时声明多个变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> number <span class=\"type\">int</span> <span class=\"comment\">// 声明一个变量名为 number，类型为 int，初始值为 0（int 类型的零值）</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> isEnabled <span class=\"type\">bool</span> <span class=\"comment\">// 声明一个变量名为 isEnabled，类型为 bool，初始值为 false（bool 类型的零值）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//短变量声明（:=）,使用短变量声明可以在函数内部声明并初始化变量，而不需要使用 var 关键字</span></span><br><span class=\"line\">x := <span class=\"number\">10</span> <span class=\"comment\">// 声明并初始化一个整型变量 x，类型由编译器自动推断为 int</span></span><br><span class=\"line\">name, age := <span class=\"string\">&quot;Bob&quot;</span>, <span class=\"number\">25</span> <span class=\"comment\">// 同时声明并初始化多个变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"Go第三天Array和Slice","date":"2023-12-02T05:06:54.000Z","_content":"# 数组\n- 数组是一种数据类型固定长度的序列。\n- 数组定义：var a [长度] int，数组长度是一个常量，类型的组成部分。一旦定义，长度就不能变了。\n> Go中的数组是值类型，当数组传递到函数时，会进行值复制，因此对函数内部的数组进行修改不会影响原始数组。\n\n{% codeblock lang:go %}\nvar arr [5]int //声明一个包含5个整数的数组\n\narr:=[3]int{10,20,30}//初始化数组并指定初始值\n\narr:=[0]=100//修改数组的第一个元素为100\nvalue:=arr[1]//获取数组的第二个元素值\n\nlength:=len(arr)//获取数组长度\n\nvar mat[3][3]int //声明一个3x3的二维整数数组\n{% endcodeblock %}\n\n# slice 切片\n在大多数情况下，Go更倾向于使用切片，因为切片具有动态长度且更有灵活，长度不固定，切片是对数组的抽象，切片的长度可以动态增长和缩减。\n{% codeblock lang:go %}\nvar slice []int //声明一个整数切片，初始化为null\n\nslice:=[]int{10,20,30}//初始化切片指定默认值\n\nslice := arr[1:4] // 创建一个包含 arr 数组索引为 1 到 3 的切片\n\nslice := arr[2:] // 从索引为 2 的元素开始直到末尾\nslice := arr[:3] // 从开始到索引为 2 的元素（不包含索引为 3 的元素）\nslice := arr[:] // 完整拷贝整个数组\n\nslice = append(slice, 6) // 在切片末尾追加一个元素\nslice = append(slice, 7, 8, 9) // 在切片末尾追加多个元素\n\nslice = append(slice, 10) // 当容量不足时，切片会自动扩容\n\nlength := len(slice) // 获取切片的长度\ncapacity := cap(slice) // 获取切片的容量\n{% endcodeblock %}\n> 在 Go 中，切片的扩容是指在切片容量不足以容纳新添加元素时，系统会自动为切片分配更多的内存空间，使其能够容纳更多的元素。\n## 使用make创建切片\n\nmake用于创建动态长度的数据结构，切片、或者映射、通道等内建函数。\n\n{% codeblock lang:go %}\nslice := make([]int, 5) // 创建一个包含5个整数的切片，初始值为整数类型的零值\nslice := make([]int, 5, 10) // 创建一个长度为5，容量为10的切片\n\n\n{% endcodeblock %}\n\n\n>  总结：数组适合于固定长度、静态集合的场景，而切片则更适用于需要动态改变长度、灵活操作数据集合的情况。","source":"_posts/1.计算机编程/Go第三天.md","raw":"---\ntitle: Go第三天Array和Slice\ndate: 2023-12-02 13:06:54\ntags:\n- GoLang\n---\n# 数组\n- 数组是一种数据类型固定长度的序列。\n- 数组定义：var a [长度] int，数组长度是一个常量，类型的组成部分。一旦定义，长度就不能变了。\n> Go中的数组是值类型，当数组传递到函数时，会进行值复制，因此对函数内部的数组进行修改不会影响原始数组。\n\n{% codeblock lang:go %}\nvar arr [5]int //声明一个包含5个整数的数组\n\narr:=[3]int{10,20,30}//初始化数组并指定初始值\n\narr:=[0]=100//修改数组的第一个元素为100\nvalue:=arr[1]//获取数组的第二个元素值\n\nlength:=len(arr)//获取数组长度\n\nvar mat[3][3]int //声明一个3x3的二维整数数组\n{% endcodeblock %}\n\n# slice 切片\n在大多数情况下，Go更倾向于使用切片，因为切片具有动态长度且更有灵活，长度不固定，切片是对数组的抽象，切片的长度可以动态增长和缩减。\n{% codeblock lang:go %}\nvar slice []int //声明一个整数切片，初始化为null\n\nslice:=[]int{10,20,30}//初始化切片指定默认值\n\nslice := arr[1:4] // 创建一个包含 arr 数组索引为 1 到 3 的切片\n\nslice := arr[2:] // 从索引为 2 的元素开始直到末尾\nslice := arr[:3] // 从开始到索引为 2 的元素（不包含索引为 3 的元素）\nslice := arr[:] // 完整拷贝整个数组\n\nslice = append(slice, 6) // 在切片末尾追加一个元素\nslice = append(slice, 7, 8, 9) // 在切片末尾追加多个元素\n\nslice = append(slice, 10) // 当容量不足时，切片会自动扩容\n\nlength := len(slice) // 获取切片的长度\ncapacity := cap(slice) // 获取切片的容量\n{% endcodeblock %}\n> 在 Go 中，切片的扩容是指在切片容量不足以容纳新添加元素时，系统会自动为切片分配更多的内存空间，使其能够容纳更多的元素。\n## 使用make创建切片\n\nmake用于创建动态长度的数据结构，切片、或者映射、通道等内建函数。\n\n{% codeblock lang:go %}\nslice := make([]int, 5) // 创建一个包含5个整数的切片，初始值为整数类型的零值\nslice := make([]int, 5, 10) // 创建一个长度为5，容量为10的切片\n\n\n{% endcodeblock %}\n\n\n>  总结：数组适合于固定长度、静态集合的场景，而切片则更适用于需要动态改变长度、灵活操作数据集合的情况。","slug":"1.计算机编程/Go第三天","published":1,"updated":"2023-12-02T05:35:58.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqm0006jkgl76ct18hp","content":"<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><ul>\n<li>数组是一种数据类型固定长度的序列。</li>\n<li>数组定义：var a [长度] int，数组长度是一个常量，类型的组成部分。一旦定义，长度就不能变了。<blockquote>\n<p>Go中的数组是值类型，当数组传递到函数时，会进行值复制，因此对函数内部的数组进行修改不会影响原始数组。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr [<span class=\"number\">5</span>]<span class=\"type\">int</span> <span class=\"comment\">//声明一个包含5个整数的数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr:=[<span class=\"number\">3</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>&#125;<span class=\"comment\">//初始化数组并指定初始值</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr:=[<span class=\"number\">0</span>]=<span class=\"number\">100</span><span class=\"comment\">//修改数组的第一个元素为100</span></span><br><span class=\"line\">value:=arr[<span class=\"number\">1</span>]<span class=\"comment\">//获取数组的第二个元素值</span></span><br><span class=\"line\"></span><br><span class=\"line\">length:=<span class=\"built_in\">len</span>(arr)<span class=\"comment\">//获取数组长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mat[<span class=\"number\">3</span>][<span class=\"number\">3</span>]<span class=\"type\">int</span> <span class=\"comment\">//声明一个3x3的二维整数数组</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"slice-切片\"><a href=\"#slice-切片\" class=\"headerlink\" title=\"slice 切片\"></a>slice 切片</h1><p>在大多数情况下，Go更倾向于使用切片，因为切片具有动态长度且更有灵活，长度不固定，切片是对数组的抽象，切片的长度可以动态增长和缩减。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> slice []<span class=\"type\">int</span> <span class=\"comment\">//声明一个整数切片，初始化为null</span></span><br><span class=\"line\"></span><br><span class=\"line\">slice:=[]<span class=\"type\">int</span>&#123;<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>&#125;<span class=\"comment\">//初始化切片指定默认值</span></span><br><span class=\"line\"></span><br><span class=\"line\">slice := arr[<span class=\"number\">1</span>:<span class=\"number\">4</span>] <span class=\"comment\">// 创建一个包含 arr 数组索引为 1 到 3 的切片</span></span><br><span class=\"line\"></span><br><span class=\"line\">slice := arr[<span class=\"number\">2</span>:] <span class=\"comment\">// 从索引为 2 的元素开始直到末尾</span></span><br><span class=\"line\">slice := arr[:<span class=\"number\">3</span>] <span class=\"comment\">// 从开始到索引为 2 的元素（不包含索引为 3 的元素）</span></span><br><span class=\"line\">slice := arr[:] <span class=\"comment\">// 完整拷贝整个数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">slice = <span class=\"built_in\">append</span>(slice, <span class=\"number\">6</span>) <span class=\"comment\">// 在切片末尾追加一个元素</span></span><br><span class=\"line\">slice = <span class=\"built_in\">append</span>(slice, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>) <span class=\"comment\">// 在切片末尾追加多个元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">slice = <span class=\"built_in\">append</span>(slice, <span class=\"number\">10</span>) <span class=\"comment\">// 当容量不足时，切片会自动扩容</span></span><br><span class=\"line\"></span><br><span class=\"line\">length := <span class=\"built_in\">len</span>(slice) <span class=\"comment\">// 获取切片的长度</span></span><br><span class=\"line\">capacity := <span class=\"built_in\">cap</span>(slice) <span class=\"comment\">// 获取切片的容量</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在 Go 中，切片的扩容是指在切片容量不足以容纳新添加元素时，系统会自动为切片分配更多的内存空间，使其能够容纳更多的元素。</p>\n</blockquote>\n<h2 id=\"使用make创建切片\"><a href=\"#使用make创建切片\" class=\"headerlink\" title=\"使用make创建切片\"></a>使用make创建切片</h2><p>make用于创建动态长度的数据结构，切片、或者映射、通道等内建函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slice := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">5</span>) <span class=\"comment\">// 创建一个包含5个整数的切片，初始值为整数类型的零值</span></span><br><span class=\"line\">slice := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>) <span class=\"comment\">// 创建一个长度为5，容量为10的切片</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p> 总结：数组适合于固定长度、静态集合的场景，而切片则更适用于需要动态改变长度、灵活操作数据集合的情况。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><ul>\n<li>数组是一种数据类型固定长度的序列。</li>\n<li>数组定义：var a [长度] int，数组长度是一个常量，类型的组成部分。一旦定义，长度就不能变了。<blockquote>\n<p>Go中的数组是值类型，当数组传递到函数时，会进行值复制，因此对函数内部的数组进行修改不会影响原始数组。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr [<span class=\"number\">5</span>]<span class=\"type\">int</span> <span class=\"comment\">//声明一个包含5个整数的数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr:=[<span class=\"number\">3</span>]<span class=\"type\">int</span>&#123;<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>&#125;<span class=\"comment\">//初始化数组并指定初始值</span></span><br><span class=\"line\"></span><br><span class=\"line\">arr:=[<span class=\"number\">0</span>]=<span class=\"number\">100</span><span class=\"comment\">//修改数组的第一个元素为100</span></span><br><span class=\"line\">value:=arr[<span class=\"number\">1</span>]<span class=\"comment\">//获取数组的第二个元素值</span></span><br><span class=\"line\"></span><br><span class=\"line\">length:=<span class=\"built_in\">len</span>(arr)<span class=\"comment\">//获取数组长度</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mat[<span class=\"number\">3</span>][<span class=\"number\">3</span>]<span class=\"type\">int</span> <span class=\"comment\">//声明一个3x3的二维整数数组</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"slice-切片\"><a href=\"#slice-切片\" class=\"headerlink\" title=\"slice 切片\"></a>slice 切片</h1><p>在大多数情况下，Go更倾向于使用切片，因为切片具有动态长度且更有灵活，长度不固定，切片是对数组的抽象，切片的长度可以动态增长和缩减。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> slice []<span class=\"type\">int</span> <span class=\"comment\">//声明一个整数切片，初始化为null</span></span><br><span class=\"line\"></span><br><span class=\"line\">slice:=[]<span class=\"type\">int</span>&#123;<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>&#125;<span class=\"comment\">//初始化切片指定默认值</span></span><br><span class=\"line\"></span><br><span class=\"line\">slice := arr[<span class=\"number\">1</span>:<span class=\"number\">4</span>] <span class=\"comment\">// 创建一个包含 arr 数组索引为 1 到 3 的切片</span></span><br><span class=\"line\"></span><br><span class=\"line\">slice := arr[<span class=\"number\">2</span>:] <span class=\"comment\">// 从索引为 2 的元素开始直到末尾</span></span><br><span class=\"line\">slice := arr[:<span class=\"number\">3</span>] <span class=\"comment\">// 从开始到索引为 2 的元素（不包含索引为 3 的元素）</span></span><br><span class=\"line\">slice := arr[:] <span class=\"comment\">// 完整拷贝整个数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">slice = <span class=\"built_in\">append</span>(slice, <span class=\"number\">6</span>) <span class=\"comment\">// 在切片末尾追加一个元素</span></span><br><span class=\"line\">slice = <span class=\"built_in\">append</span>(slice, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>) <span class=\"comment\">// 在切片末尾追加多个元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">slice = <span class=\"built_in\">append</span>(slice, <span class=\"number\">10</span>) <span class=\"comment\">// 当容量不足时，切片会自动扩容</span></span><br><span class=\"line\"></span><br><span class=\"line\">length := <span class=\"built_in\">len</span>(slice) <span class=\"comment\">// 获取切片的长度</span></span><br><span class=\"line\">capacity := <span class=\"built_in\">cap</span>(slice) <span class=\"comment\">// 获取切片的容量</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在 Go 中，切片的扩容是指在切片容量不足以容纳新添加元素时，系统会自动为切片分配更多的内存空间，使其能够容纳更多的元素。</p>\n</blockquote>\n<h2 id=\"使用make创建切片\"><a href=\"#使用make创建切片\" class=\"headerlink\" title=\"使用make创建切片\"></a>使用make创建切片</h2><p>make用于创建动态长度的数据结构，切片、或者映射、通道等内建函数。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">slice := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">5</span>) <span class=\"comment\">// 创建一个包含5个整数的切片，初始值为整数类型的零值</span></span><br><span class=\"line\">slice := <span class=\"built_in\">make</span>([]<span class=\"type\">int</span>, <span class=\"number\">5</span>, <span class=\"number\">10</span>) <span class=\"comment\">// 创建一个长度为5，容量为10的切片</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p> 总结：数组适合于固定长度、静态集合的场景，而切片则更适用于需要动态改变长度、灵活操作数据集合的情况。</p>\n</blockquote>\n"},{"title":"Go第一天的安装与环境配置","date":"2023-11-25T07:00:00.000Z","_content":"\n# Go安装\n## 下载GO\n- WIndow安装\n> 下载地址：https://golang.org/dl/ \n\n# 安装之后配置环境变量\n\nGOPATH是一个环境变量，用来表明你写的go项目的存放路径\n\n![下载](/../Img/0231125155322.png)\n\nGOPATH路径最好只设置一个，所有的项目代码都放到GOPATH的src目录下。\n\n![下载](/../Img/230231125155410.png)\n\n# go的项目目录\n\n在项目路径下分别为GOPATH，新建目录文件夹\n- bin 用来存放编译后生成的可执行文件\n- pkg 用来存放编译后的生成文件\n- src 用来存放源码文件\n\n# go镜像安装\n\n打开你的 PowerShell 并执行\n\n>  C:\\\\>\\$env:GO111MODULE =\"on\"C:\\\\>\\$env:GOPROXY =\"https://goproxy.cn\"\n\n或者\n\n1. 打开“开始”并搜索“env”\n\n2. 选择“编辑系统环境变量”\n\n3. 点击“环境变量…”按钮\n\n4. 在“<你的用户名>的用户变量”章节下（上半部分）\n\n5. 点击“新建…”按钮\n\n6. 选择“变量名”输入框并输入“GO111MODULE”\n\n7. 选择“变量值”输入框并输入“on”\n\n8. 点击“确定”按钮\n\n9. 点击“新建…”按钮\n\n10. 选择“变量名”输入框并输入“GOPROXY”\n\n11. 选择“变量值”输入框并输入“https://goproxy.cn”\n\n12. 点击“确定”按钮\n\n# 创建项目\n命令行输入：go mod init\n\n在src目录下创建hello目录，在目录内创建main.go文件\n\n{% codeblock lang:go %}\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello World!\")\n}\n\n{% endcodeblock %}\n# 了解一些基础的知识\nGO主要的特征\n- 垃圾回收机制：GO的运行时系统会自动回收不再使用的内存和.net类似。\n- 并发编程: Go语言原生支持并发编程\n- 反射: 同样和.net一样都支持反射，允许程序在运行时检查和操作自身的结构。\n- 函数多返回值：函数可以返回多个值。\n- 匿名函数和闭包：Go支持匿名函数和闭包的概念。\n- 语言交互性：支持与其他语言交互性，可以通过内置工具和包来与C语言进行交互。\n- 类型和接口：具有类型和接口概念，有静态类型系统。","source":"_posts/1.计算机编程/Go第一天.md","raw":"---\ntitle: Go第一天的安装与环境配置\ndate: 2023-11-25 15:00:00\ntags: \n- GoLang\n---\n\n# Go安装\n## 下载GO\n- WIndow安装\n> 下载地址：https://golang.org/dl/ \n\n# 安装之后配置环境变量\n\nGOPATH是一个环境变量，用来表明你写的go项目的存放路径\n\n![下载](/../Img/0231125155322.png)\n\nGOPATH路径最好只设置一个，所有的项目代码都放到GOPATH的src目录下。\n\n![下载](/../Img/230231125155410.png)\n\n# go的项目目录\n\n在项目路径下分别为GOPATH，新建目录文件夹\n- bin 用来存放编译后生成的可执行文件\n- pkg 用来存放编译后的生成文件\n- src 用来存放源码文件\n\n# go镜像安装\n\n打开你的 PowerShell 并执行\n\n>  C:\\\\>\\$env:GO111MODULE =\"on\"C:\\\\>\\$env:GOPROXY =\"https://goproxy.cn\"\n\n或者\n\n1. 打开“开始”并搜索“env”\n\n2. 选择“编辑系统环境变量”\n\n3. 点击“环境变量…”按钮\n\n4. 在“<你的用户名>的用户变量”章节下（上半部分）\n\n5. 点击“新建…”按钮\n\n6. 选择“变量名”输入框并输入“GO111MODULE”\n\n7. 选择“变量值”输入框并输入“on”\n\n8. 点击“确定”按钮\n\n9. 点击“新建…”按钮\n\n10. 选择“变量名”输入框并输入“GOPROXY”\n\n11. 选择“变量值”输入框并输入“https://goproxy.cn”\n\n12. 点击“确定”按钮\n\n# 创建项目\n命令行输入：go mod init\n\n在src目录下创建hello目录，在目录内创建main.go文件\n\n{% codeblock lang:go %}\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"Hello World!\")\n}\n\n{% endcodeblock %}\n# 了解一些基础的知识\nGO主要的特征\n- 垃圾回收机制：GO的运行时系统会自动回收不再使用的内存和.net类似。\n- 并发编程: Go语言原生支持并发编程\n- 反射: 同样和.net一样都支持反射，允许程序在运行时检查和操作自身的结构。\n- 函数多返回值：函数可以返回多个值。\n- 匿名函数和闭包：Go支持匿名函数和闭包的概念。\n- 语言交互性：支持与其他语言交互性，可以通过内置工具和包来与C语言进行交互。\n- 类型和接口：具有类型和接口概念，有静态类型系统。","slug":"1.计算机编程/Go第一天","published":1,"updated":"2023-12-18T11:11:02.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqn0007jkglavyq7147","content":"<h1 id=\"Go安装\"><a href=\"#Go安装\" class=\"headerlink\" title=\"Go安装\"></a>Go安装</h1><h2 id=\"下载GO\"><a href=\"#下载GO\" class=\"headerlink\" title=\"下载GO\"></a>下载GO</h2><ul>\n<li>WIndow安装<blockquote>\n<p>下载地址：<a href=\"https://golang.org/dl/\">https://golang.org/dl/</a></p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"安装之后配置环境变量\"><a href=\"#安装之后配置环境变量\" class=\"headerlink\" title=\"安装之后配置环境变量\"></a>安装之后配置环境变量</h1><p>GOPATH是一个环境变量，用来表明你写的go项目的存放路径</p>\n<p><img src=\"/../Img/0231125155322.png\" alt=\"下载\"></p>\n<p>GOPATH路径最好只设置一个，所有的项目代码都放到GOPATH的src目录下。</p>\n<p><img src=\"/../Img/230231125155410.png\" alt=\"下载\"></p>\n<h1 id=\"go的项目目录\"><a href=\"#go的项目目录\" class=\"headerlink\" title=\"go的项目目录\"></a>go的项目目录</h1><p>在项目路径下分别为GOPATH，新建目录文件夹</p>\n<ul>\n<li>bin 用来存放编译后生成的可执行文件</li>\n<li>pkg 用来存放编译后的生成文件</li>\n<li>src 用来存放源码文件</li>\n</ul>\n<h1 id=\"go镜像安装\"><a href=\"#go镜像安装\" class=\"headerlink\" title=\"go镜像安装\"></a>go镜像安装</h1><p>打开你的 PowerShell 并执行</p>\n<blockquote>\n<p> C:\\&gt;$env:GO111MODULE &#x3D;”on”C:\\&gt;$env:GOPROXY &#x3D;”<a href=\"https://goproxy.cn/\">https://goproxy.cn</a>“</p>\n</blockquote>\n<p>或者</p>\n<ol>\n<li><p>打开“开始”并搜索“env”</p>\n</li>\n<li><p>选择“编辑系统环境变量”</p>\n</li>\n<li><p>点击“环境变量…”按钮</p>\n</li>\n<li><p>在“&lt;你的用户名&gt;的用户变量”章节下（上半部分）</p>\n</li>\n<li><p>点击“新建…”按钮</p>\n</li>\n<li><p>选择“变量名”输入框并输入“GO111MODULE”</p>\n</li>\n<li><p>选择“变量值”输入框并输入“on”</p>\n</li>\n<li><p>点击“确定”按钮</p>\n</li>\n<li><p>点击“新建…”按钮</p>\n</li>\n<li><p>选择“变量名”输入框并输入“GOPROXY”</p>\n</li>\n<li><p>选择“变量值”输入框并输入“<a href=\"https://goproxy.cn”/\">https://goproxy.cn”</a></p>\n</li>\n<li><p>点击“确定”按钮</p>\n</li>\n</ol>\n<h1 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h1><p>命令行输入：go mod init</p>\n<p>在src目录下创建hello目录，在目录内创建main.go文件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"了解一些基础的知识\"><a href=\"#了解一些基础的知识\" class=\"headerlink\" title=\"了解一些基础的知识\"></a>了解一些基础的知识</h1><p>GO主要的特征</p>\n<ul>\n<li>垃圾回收机制：GO的运行时系统会自动回收不再使用的内存和.net类似。</li>\n<li>并发编程: Go语言原生支持并发编程</li>\n<li>反射: 同样和.net一样都支持反射，允许程序在运行时检查和操作自身的结构。</li>\n<li>函数多返回值：函数可以返回多个值。</li>\n<li>匿名函数和闭包：Go支持匿名函数和闭包的概念。</li>\n<li>语言交互性：支持与其他语言交互性，可以通过内置工具和包来与C语言进行交互。</li>\n<li>类型和接口：具有类型和接口概念，有静态类型系统。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Go安装\"><a href=\"#Go安装\" class=\"headerlink\" title=\"Go安装\"></a>Go安装</h1><h2 id=\"下载GO\"><a href=\"#下载GO\" class=\"headerlink\" title=\"下载GO\"></a>下载GO</h2><ul>\n<li>WIndow安装<blockquote>\n<p>下载地址：<a href=\"https://golang.org/dl/\">https://golang.org/dl/</a></p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"安装之后配置环境变量\"><a href=\"#安装之后配置环境变量\" class=\"headerlink\" title=\"安装之后配置环境变量\"></a>安装之后配置环境变量</h1><p>GOPATH是一个环境变量，用来表明你写的go项目的存放路径</p>\n<p><img src=\"/../Img/0231125155322.png\" alt=\"下载\"></p>\n<p>GOPATH路径最好只设置一个，所有的项目代码都放到GOPATH的src目录下。</p>\n<p><img src=\"/../Img/230231125155410.png\" alt=\"下载\"></p>\n<h1 id=\"go的项目目录\"><a href=\"#go的项目目录\" class=\"headerlink\" title=\"go的项目目录\"></a>go的项目目录</h1><p>在项目路径下分别为GOPATH，新建目录文件夹</p>\n<ul>\n<li>bin 用来存放编译后生成的可执行文件</li>\n<li>pkg 用来存放编译后的生成文件</li>\n<li>src 用来存放源码文件</li>\n</ul>\n<h1 id=\"go镜像安装\"><a href=\"#go镜像安装\" class=\"headerlink\" title=\"go镜像安装\"></a>go镜像安装</h1><p>打开你的 PowerShell 并执行</p>\n<blockquote>\n<p> C:\\&gt;$env:GO111MODULE &#x3D;”on”C:\\&gt;$env:GOPROXY &#x3D;”<a href=\"https://goproxy.cn/\">https://goproxy.cn</a>“</p>\n</blockquote>\n<p>或者</p>\n<ol>\n<li><p>打开“开始”并搜索“env”</p>\n</li>\n<li><p>选择“编辑系统环境变量”</p>\n</li>\n<li><p>点击“环境变量…”按钮</p>\n</li>\n<li><p>在“&lt;你的用户名&gt;的用户变量”章节下（上半部分）</p>\n</li>\n<li><p>点击“新建…”按钮</p>\n</li>\n<li><p>选择“变量名”输入框并输入“GO111MODULE”</p>\n</li>\n<li><p>选择“变量值”输入框并输入“on”</p>\n</li>\n<li><p>点击“确定”按钮</p>\n</li>\n<li><p>点击“新建…”按钮</p>\n</li>\n<li><p>选择“变量名”输入框并输入“GOPROXY”</p>\n</li>\n<li><p>选择“变量值”输入框并输入“<a href=\"https://goproxy.cn”/\">https://goproxy.cn”</a></p>\n</li>\n<li><p>点击“确定”按钮</p>\n</li>\n</ol>\n<h1 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h1><p>命令行输入：go mod init</p>\n<p>在src目录下创建hello目录，在目录内创建main.go文件</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;Hello World!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"了解一些基础的知识\"><a href=\"#了解一些基础的知识\" class=\"headerlink\" title=\"了解一些基础的知识\"></a>了解一些基础的知识</h1><p>GO主要的特征</p>\n<ul>\n<li>垃圾回收机制：GO的运行时系统会自动回收不再使用的内存和.net类似。</li>\n<li>并发编程: Go语言原生支持并发编程</li>\n<li>反射: 同样和.net一样都支持反射，允许程序在运行时检查和操作自身的结构。</li>\n<li>函数多返回值：函数可以返回多个值。</li>\n<li>匿名函数和闭包：Go支持匿名函数和闭包的概念。</li>\n<li>语言交互性：支持与其他语言交互性，可以通过内置工具和包来与C语言进行交互。</li>\n<li>类型和接口：具有类型和接口概念，有静态类型系统。</li>\n</ul>\n"},{"title":"运行时、运行库、运行环境","date":"2019-01-07T05:11:33.000Z","_content":"\n## 运行时（Runtime）\n\n运行时(RunTime) **运行时是指程序在实际执行阶段的时间段**，也就是程序在计算机上运行时的环境和状态。\n它包括了程序的生命周期、内存分配和释放、指令执行、异常处理、多线程管理等。**主要是关注的是程序的执行状态**\n\n---\n## 运行库 (Runtime Library)\n\n运行库是一种或一组库或者函数集合，用于支持编程语言的运行时功能。\n运行库包含了一些通用的函数，类和工具、库等。\n\n---\n\n## 运行时环境 (Runtime Environment)\n\n运行时环境是指程序实际执行阶段的环境和状态。如编程语言的支持，不同编程语言需要特定的运行时环境来执行、例如C#需要.NET Framework或.NET Core 。\n","source":"_posts/1.计算机编程/运行时、运行库、运行环境.md","raw":"---\ntitle: 运行时、运行库、运行环境\ndate: 2019-01-07 13:11:33\ntags: 计算机编程\n---\n\n## 运行时（Runtime）\n\n运行时(RunTime) **运行时是指程序在实际执行阶段的时间段**，也就是程序在计算机上运行时的环境和状态。\n它包括了程序的生命周期、内存分配和释放、指令执行、异常处理、多线程管理等。**主要是关注的是程序的执行状态**\n\n---\n## 运行库 (Runtime Library)\n\n运行库是一种或一组库或者函数集合，用于支持编程语言的运行时功能。\n运行库包含了一些通用的函数，类和工具、库等。\n\n---\n\n## 运行时环境 (Runtime Environment)\n\n运行时环境是指程序实际执行阶段的环境和状态。如编程语言的支持，不同编程语言需要特定的运行时环境来执行、例如C#需要.NET Framework或.NET Core 。\n","slug":"1.计算机编程/运行时、运行库、运行环境","published":1,"updated":"2023-10-17T13:16:11.416Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqo000ajkgldd2za18h","content":"<h2 id=\"运行时（Runtime）\"><a href=\"#运行时（Runtime）\" class=\"headerlink\" title=\"运行时（Runtime）\"></a>运行时（Runtime）</h2><p>运行时(RunTime) <strong>运行时是指程序在实际执行阶段的时间段</strong>，也就是程序在计算机上运行时的环境和状态。<br>它包括了程序的生命周期、内存分配和释放、指令执行、异常处理、多线程管理等。<strong>主要是关注的是程序的执行状态</strong></p>\n<hr>\n<h2 id=\"运行库-Runtime-Library\"><a href=\"#运行库-Runtime-Library\" class=\"headerlink\" title=\"运行库 (Runtime Library)\"></a>运行库 (Runtime Library)</h2><p>运行库是一种或一组库或者函数集合，用于支持编程语言的运行时功能。<br>运行库包含了一些通用的函数，类和工具、库等。</p>\n<hr>\n<h2 id=\"运行时环境-Runtime-Environment\"><a href=\"#运行时环境-Runtime-Environment\" class=\"headerlink\" title=\"运行时环境 (Runtime Environment)\"></a>运行时环境 (Runtime Environment)</h2><p>运行时环境是指程序实际执行阶段的环境和状态。如编程语言的支持，不同编程语言需要特定的运行时环境来执行、例如C#需要.NET Framework或.NET Core 。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"运行时（Runtime）\"><a href=\"#运行时（Runtime）\" class=\"headerlink\" title=\"运行时（Runtime）\"></a>运行时（Runtime）</h2><p>运行时(RunTime) <strong>运行时是指程序在实际执行阶段的时间段</strong>，也就是程序在计算机上运行时的环境和状态。<br>它包括了程序的生命周期、内存分配和释放、指令执行、异常处理、多线程管理等。<strong>主要是关注的是程序的执行状态</strong></p>\n<hr>\n<h2 id=\"运行库-Runtime-Library\"><a href=\"#运行库-Runtime-Library\" class=\"headerlink\" title=\"运行库 (Runtime Library)\"></a>运行库 (Runtime Library)</h2><p>运行库是一种或一组库或者函数集合，用于支持编程语言的运行时功能。<br>运行库包含了一些通用的函数，类和工具、库等。</p>\n<hr>\n<h2 id=\"运行时环境-Runtime-Environment\"><a href=\"#运行时环境-Runtime-Environment\" class=\"headerlink\" title=\"运行时环境 (Runtime Environment)\"></a>运行时环境 (Runtime Environment)</h2><p>运行时环境是指程序实际执行阶段的环境和状态。如编程语言的支持，不同编程语言需要特定的运行时环境来执行、例如C#需要.NET Framework或.NET Core 。</p>\n"},{"title":"ES6的第一天","date":"2019-10-07T11:00:00.000Z","_content":"\n## ES6 的背景知识\nES6 (ECMAscript) 简称ES是一种编写脚本编程语言，主要用于网页开发中，这是一个基于对象的脚本语言，Netscape(网景)公司开发，后来成为国际标准。\n- **起源**：1995年创建这门语言，被称为javaScript，为了避免商标问题，被标准化为ECMAScript(ECMA为欧洲制造商协会)。\n- **标准化**：1997年ECMAScript被标准化为ECMA-262，标准定义了一些核心功能，如数据类型、操作费、语法等。\n- **ECMAScript3(ES3)**：1999年发布，定义了一些基础语言特性。\n- **ECMAScript5(ES5)**: 2009年发布，引入严格模式，json支持等。\n- **ECMAScript6(ES6)**：2015年发布，带来重大语言改进，如箭头函数、类、模块系统等。\n## ES6 环境\n目前大部分浏览器都支持ES6的新特性，如Chrome 、Edge 、Firefox \n- 首先代码编辑器选择，可以选择Visual Studio Code\n- 安装Node.js，ES6需要使用Node.js来运行代码。\n\n","source":"_posts/2.前端笔记/ES6的第一天.md","raw":"---\ntitle: ES6的第一天\ndate: 2019-10-07 19:00:00\ncategories: 前端笔记\ntags: \n- 前端笔记\n- ES6\n---\n\n## ES6 的背景知识\nES6 (ECMAscript) 简称ES是一种编写脚本编程语言，主要用于网页开发中，这是一个基于对象的脚本语言，Netscape(网景)公司开发，后来成为国际标准。\n- **起源**：1995年创建这门语言，被称为javaScript，为了避免商标问题，被标准化为ECMAScript(ECMA为欧洲制造商协会)。\n- **标准化**：1997年ECMAScript被标准化为ECMA-262，标准定义了一些核心功能，如数据类型、操作费、语法等。\n- **ECMAScript3(ES3)**：1999年发布，定义了一些基础语言特性。\n- **ECMAScript5(ES5)**: 2009年发布，引入严格模式，json支持等。\n- **ECMAScript6(ES6)**：2015年发布，带来重大语言改进，如箭头函数、类、模块系统等。\n## ES6 环境\n目前大部分浏览器都支持ES6的新特性，如Chrome 、Edge 、Firefox \n- 首先代码编辑器选择，可以选择Visual Studio Code\n- 安装Node.js，ES6需要使用Node.js来运行代码。\n\n","slug":"2.前端笔记/ES6的第一天","published":1,"updated":"2023-11-26T09:01:40.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqo000bjkgl0cex385i","content":"<h2 id=\"ES6-的背景知识\"><a href=\"#ES6-的背景知识\" class=\"headerlink\" title=\"ES6 的背景知识\"></a>ES6 的背景知识</h2><p>ES6 (ECMAscript) 简称ES是一种编写脚本编程语言，主要用于网页开发中，这是一个基于对象的脚本语言，Netscape(网景)公司开发，后来成为国际标准。</p>\n<ul>\n<li><strong>起源</strong>：1995年创建这门语言，被称为javaScript，为了避免商标问题，被标准化为ECMAScript(ECMA为欧洲制造商协会)。</li>\n<li><strong>标准化</strong>：1997年ECMAScript被标准化为ECMA-262，标准定义了一些核心功能，如数据类型、操作费、语法等。</li>\n<li>**ECMAScript3(ES3)**：1999年发布，定义了一些基础语言特性。</li>\n<li><strong>ECMAScript5(ES5)</strong>: 2009年发布，引入严格模式，json支持等。</li>\n<li>**ECMAScript6(ES6)**：2015年发布，带来重大语言改进，如箭头函数、类、模块系统等。</li>\n</ul>\n<h2 id=\"ES6-环境\"><a href=\"#ES6-环境\" class=\"headerlink\" title=\"ES6 环境\"></a>ES6 环境</h2><p>目前大部分浏览器都支持ES6的新特性，如Chrome 、Edge 、Firefox </p>\n<ul>\n<li>首先代码编辑器选择，可以选择Visual Studio Code</li>\n<li>安装Node.js，ES6需要使用Node.js来运行代码。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ES6-的背景知识\"><a href=\"#ES6-的背景知识\" class=\"headerlink\" title=\"ES6 的背景知识\"></a>ES6 的背景知识</h2><p>ES6 (ECMAscript) 简称ES是一种编写脚本编程语言，主要用于网页开发中，这是一个基于对象的脚本语言，Netscape(网景)公司开发，后来成为国际标准。</p>\n<ul>\n<li><strong>起源</strong>：1995年创建这门语言，被称为javaScript，为了避免商标问题，被标准化为ECMAScript(ECMA为欧洲制造商协会)。</li>\n<li><strong>标准化</strong>：1997年ECMAScript被标准化为ECMA-262，标准定义了一些核心功能，如数据类型、操作费、语法等。</li>\n<li>**ECMAScript3(ES3)**：1999年发布，定义了一些基础语言特性。</li>\n<li><strong>ECMAScript5(ES5)</strong>: 2009年发布，引入严格模式，json支持等。</li>\n<li>**ECMAScript6(ES6)**：2015年发布，带来重大语言改进，如箭头函数、类、模块系统等。</li>\n</ul>\n<h2 id=\"ES6-环境\"><a href=\"#ES6-环境\" class=\"headerlink\" title=\"ES6 环境\"></a>ES6 环境</h2><p>目前大部分浏览器都支持ES6的新特性，如Chrome 、Edge 、Firefox </p>\n<ul>\n<li>首先代码编辑器选择，可以选择Visual Studio Code</li>\n<li>安装Node.js，ES6需要使用Node.js来运行代码。</li>\n</ul>\n"},{"title":"Node.js 、npm、cnpm、yran主要作用","date":"2019-01-08T10:31:32.000Z","_content":"\n## Node.js\n\nNode.js是运行javaScript代码的运行时的环境平台([什么是运行时？](../1.计算机编程/运行时、运行库、运行环境.md))，通常用于服务器端开发，构建命令行工具和其他类型的应用程序。 可以开发服务器端应用，与文件系统、网络、数据库等进行交互。Node.js使用一个事件驱动、非阻塞式I/O的模式。\n\n>**什么是非阻塞式I/O**：I/O表示Input/Output，它用于表示计算机系统与外部世界（例如磁盘驱动器、网络、键盘、显示器等）之间的数据传输，用于与外部环境进行交互和数据处理。\n>- 在阻塞 I/O 模型中，当程序执行一个 I/O 操作（如读取文件、网络请求等）时，它会等待操作完成后才能继续执行后续代码。\n>- 非阻塞式 I/O 模型的优势在于它可以提高程序的并发性能，使程序能够有效地处理大量的并发请求，而不会因等待 I/O 操作而停滞。这对于网络服务器、数据库访问、文件系统操作等需要处理多个并发请求的应用程序非常有用。\n----\n\n## npm(Node Package Manager)\n\nnpm 是Node.js的官方包管理器，用于安装、管理和共享javascript包。使用npm来安装第三方库，将项目所需的依赖添加到package.json文件中，轻松管理项目的依赖关系。npm提供了命令行工具，运行脚本。\n\n----\n\n## Yarn\n Yarn 也是一个包管理器，类似于 npm，但由 Facebook 开发。它旨在解决一些 npm 的性能和安全性问题。Yarn 提供了更快的安装过程、锁定依赖版本的能力以及其他改进。开发者可以选择使用 npm 或 Yarn，具体取决于他们的偏好。\n\n----\n\n ## cnpm(China npm)\n\n一个由淘宝团队开发的 npm 镜像工具。cnpm 的主要目的是为中国的开发者提供更快速、稳定的 npm 资源下载，因为访问 npm 的官方服务器可能会有一些网络限制或速度较慢.","source":"_posts/2.前端笔记/Node.js 、npm、cnpm、yran主要作用.md","raw":"---\ntitle: Node.js 、npm、cnpm、yran主要作用\ndate: 2019-01-08 18:31:32\ncategories: 前端笔记\ntags: \n- Node.js\n---\n\n## Node.js\n\nNode.js是运行javaScript代码的运行时的环境平台([什么是运行时？](../1.计算机编程/运行时、运行库、运行环境.md))，通常用于服务器端开发，构建命令行工具和其他类型的应用程序。 可以开发服务器端应用，与文件系统、网络、数据库等进行交互。Node.js使用一个事件驱动、非阻塞式I/O的模式。\n\n>**什么是非阻塞式I/O**：I/O表示Input/Output，它用于表示计算机系统与外部世界（例如磁盘驱动器、网络、键盘、显示器等）之间的数据传输，用于与外部环境进行交互和数据处理。\n>- 在阻塞 I/O 模型中，当程序执行一个 I/O 操作（如读取文件、网络请求等）时，它会等待操作完成后才能继续执行后续代码。\n>- 非阻塞式 I/O 模型的优势在于它可以提高程序的并发性能，使程序能够有效地处理大量的并发请求，而不会因等待 I/O 操作而停滞。这对于网络服务器、数据库访问、文件系统操作等需要处理多个并发请求的应用程序非常有用。\n----\n\n## npm(Node Package Manager)\n\nnpm 是Node.js的官方包管理器，用于安装、管理和共享javascript包。使用npm来安装第三方库，将项目所需的依赖添加到package.json文件中，轻松管理项目的依赖关系。npm提供了命令行工具，运行脚本。\n\n----\n\n## Yarn\n Yarn 也是一个包管理器，类似于 npm，但由 Facebook 开发。它旨在解决一些 npm 的性能和安全性问题。Yarn 提供了更快的安装过程、锁定依赖版本的能力以及其他改进。开发者可以选择使用 npm 或 Yarn，具体取决于他们的偏好。\n\n----\n\n ## cnpm(China npm)\n\n一个由淘宝团队开发的 npm 镜像工具。cnpm 的主要目的是为中国的开发者提供更快速、稳定的 npm 资源下载，因为访问 npm 的官方服务器可能会有一些网络限制或速度较慢.","slug":"2.前端笔记/Node.js 、npm、cnpm、yran主要作用","published":1,"updated":"2023-10-18T04:58:29.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqp000ejkgld00x9e2q","content":"<h2 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a>Node.js</h2><p>Node.js是运行javaScript代码的运行时的环境平台(<a href=\"../1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/%E8%BF%90%E8%A1%8C%E6%97%B6%E3%80%81%E8%BF%90%E8%A1%8C%E5%BA%93%E3%80%81%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83.md\">什么是运行时？</a>)，通常用于服务器端开发，构建命令行工具和其他类型的应用程序。 可以开发服务器端应用，与文件系统、网络、数据库等进行交互。Node.js使用一个事件驱动、非阻塞式I&#x2F;O的模式。</p>\n<blockquote>\n<p><strong>什么是非阻塞式I&#x2F;O</strong>：I&#x2F;O表示Input&#x2F;Output，它用于表示计算机系统与外部世界（例如磁盘驱动器、网络、键盘、显示器等）之间的数据传输，用于与外部环境进行交互和数据处理。</p>\n<ul>\n<li>在阻塞 I&#x2F;O 模型中，当程序执行一个 I&#x2F;O 操作（如读取文件、网络请求等）时，它会等待操作完成后才能继续执行后续代码。</li>\n<li>非阻塞式 I&#x2F;O 模型的优势在于它可以提高程序的并发性能，使程序能够有效地处理大量的并发请求，而不会因等待 I&#x2F;O 操作而停滞。这对于网络服务器、数据库访问、文件系统操作等需要处理多个并发请求的应用程序非常有用。</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"npm-Node-Package-Manager\"><a href=\"#npm-Node-Package-Manager\" class=\"headerlink\" title=\"npm(Node Package Manager)\"></a>npm(Node Package Manager)</h2><p>npm 是Node.js的官方包管理器，用于安装、管理和共享javascript包。使用npm来安装第三方库，将项目所需的依赖添加到package.json文件中，轻松管理项目的依赖关系。npm提供了命令行工具，运行脚本。</p>\n<hr>\n<h2 id=\"Yarn\"><a href=\"#Yarn\" class=\"headerlink\" title=\"Yarn\"></a>Yarn</h2><p> Yarn 也是一个包管理器，类似于 npm，但由 Facebook 开发。它旨在解决一些 npm 的性能和安全性问题。Yarn 提供了更快的安装过程、锁定依赖版本的能力以及其他改进。开发者可以选择使用 npm 或 Yarn，具体取决于他们的偏好。</p>\n<hr>\n<h2 id=\"cnpm-China-npm\"><a href=\"#cnpm-China-npm\" class=\"headerlink\" title=\"cnpm(China npm)\"></a>cnpm(China npm)</h2><p>一个由淘宝团队开发的 npm 镜像工具。cnpm 的主要目的是为中国的开发者提供更快速、稳定的 npm 资源下载，因为访问 npm 的官方服务器可能会有一些网络限制或速度较慢.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Node-js\"><a href=\"#Node-js\" class=\"headerlink\" title=\"Node.js\"></a>Node.js</h2><p>Node.js是运行javaScript代码的运行时的环境平台(<a href=\"../1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B/%E8%BF%90%E8%A1%8C%E6%97%B6%E3%80%81%E8%BF%90%E8%A1%8C%E5%BA%93%E3%80%81%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83.md\">什么是运行时？</a>)，通常用于服务器端开发，构建命令行工具和其他类型的应用程序。 可以开发服务器端应用，与文件系统、网络、数据库等进行交互。Node.js使用一个事件驱动、非阻塞式I&#x2F;O的模式。</p>\n<blockquote>\n<p><strong>什么是非阻塞式I&#x2F;O</strong>：I&#x2F;O表示Input&#x2F;Output，它用于表示计算机系统与外部世界（例如磁盘驱动器、网络、键盘、显示器等）之间的数据传输，用于与外部环境进行交互和数据处理。</p>\n<ul>\n<li>在阻塞 I&#x2F;O 模型中，当程序执行一个 I&#x2F;O 操作（如读取文件、网络请求等）时，它会等待操作完成后才能继续执行后续代码。</li>\n<li>非阻塞式 I&#x2F;O 模型的优势在于它可以提高程序的并发性能，使程序能够有效地处理大量的并发请求，而不会因等待 I&#x2F;O 操作而停滞。这对于网络服务器、数据库访问、文件系统操作等需要处理多个并发请求的应用程序非常有用。</li>\n</ul>\n</blockquote>\n<hr>\n<h2 id=\"npm-Node-Package-Manager\"><a href=\"#npm-Node-Package-Manager\" class=\"headerlink\" title=\"npm(Node Package Manager)\"></a>npm(Node Package Manager)</h2><p>npm 是Node.js的官方包管理器，用于安装、管理和共享javascript包。使用npm来安装第三方库，将项目所需的依赖添加到package.json文件中，轻松管理项目的依赖关系。npm提供了命令行工具，运行脚本。</p>\n<hr>\n<h2 id=\"Yarn\"><a href=\"#Yarn\" class=\"headerlink\" title=\"Yarn\"></a>Yarn</h2><p> Yarn 也是一个包管理器，类似于 npm，但由 Facebook 开发。它旨在解决一些 npm 的性能和安全性问题。Yarn 提供了更快的安装过程、锁定依赖版本的能力以及其他改进。开发者可以选择使用 npm 或 Yarn，具体取决于他们的偏好。</p>\n<hr>\n<h2 id=\"cnpm-China-npm\"><a href=\"#cnpm-China-npm\" class=\"headerlink\" title=\"cnpm(China npm)\"></a>cnpm(China npm)</h2><p>一个由淘宝团队开发的 npm 镜像工具。cnpm 的主要目的是为中国的开发者提供更快速、稳定的 npm 资源下载，因为访问 npm 的官方服务器可能会有一些网络限制或速度较慢.</p>\n"},{"title":"Node.js安装与配置环境(Windows版)","date":"2019-01-07T05:11:33.000Z","_content":"\n# Nodejs安装\n## 下载Node.js\nNode.js 官方网站下载：https://nodejs.org/en/download/\n![下载](/../Img/20231016195905.png)\n## 安装\n双击打开安装下一步下一步即可，我默认的路径是 \n>C:\\Program Files\\nodejs\n\n## 查看版本\n安装成功之后，运行**cmd** \n输入**node -v**和**npm -v**分别查看node和npm的版本。\n# npm安装全局模块的路径和缓存路径\n在node.js的安装目录下新建文件夹分别为：\n> node_global\n> node_cache\n\n创建完成之后在**cmd**中执行命令\n\n```npm config set prefix \"C:\\Program Files\\nodejs\\node_global\"```\n\n```npm config set cache \"C:\\Program Files\\nodejs\\node_cache\"```\n\n**设置完成之后进行环境变量的配置分别为:**\n\n``` “环境变量”>“系统变量”：新建一个变量名为“NODE_PATH”，值为“C:\\Program Files\\nodejs\\node_global”```\n\n``` “环境变量”>“系统变量”：编辑系统里的path，添加 %NODE_PATH%```\n\n```“环境变量”>“用户变量”：编辑用户变量里的path，相应npm的路径C:\\Program Files\\nodejs\\node_global```\n\n配置完成之后，测试npm下载即可。\n","source":"_posts/2.前端笔记/Node.js安装与配置环境(Windows版).md","raw":"---\ntitle: Node.js安装与配置环境(Windows版)\ndate: 2019-01-07 13:11:33\ncategories: 前端笔记\ntags: \n- Node.js\n---\n\n# Nodejs安装\n## 下载Node.js\nNode.js 官方网站下载：https://nodejs.org/en/download/\n![下载](/../Img/20231016195905.png)\n## 安装\n双击打开安装下一步下一步即可，我默认的路径是 \n>C:\\Program Files\\nodejs\n\n## 查看版本\n安装成功之后，运行**cmd** \n输入**node -v**和**npm -v**分别查看node和npm的版本。\n# npm安装全局模块的路径和缓存路径\n在node.js的安装目录下新建文件夹分别为：\n> node_global\n> node_cache\n\n创建完成之后在**cmd**中执行命令\n\n```npm config set prefix \"C:\\Program Files\\nodejs\\node_global\"```\n\n```npm config set cache \"C:\\Program Files\\nodejs\\node_cache\"```\n\n**设置完成之后进行环境变量的配置分别为:**\n\n``` “环境变量”>“系统变量”：新建一个变量名为“NODE_PATH”，值为“C:\\Program Files\\nodejs\\node_global”```\n\n``` “环境变量”>“系统变量”：编辑系统里的path，添加 %NODE_PATH%```\n\n```“环境变量”>“用户变量”：编辑用户变量里的path，相应npm的路径C:\\Program Files\\nodejs\\node_global```\n\n配置完成之后，测试npm下载即可。\n","slug":"2.前端笔记/Node.js安装与配置环境(Windows版)","published":1,"updated":"2023-11-27T11:18:11.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqq000hjkglg5u1dh44","content":"<h1 id=\"Nodejs安装\"><a href=\"#Nodejs安装\" class=\"headerlink\" title=\"Nodejs安装\"></a>Nodejs安装</h1><h2 id=\"下载Node-js\"><a href=\"#下载Node-js\" class=\"headerlink\" title=\"下载Node.js\"></a>下载Node.js</h2><p>Node.js 官方网站下载：<a href=\"https://nodejs.org/en/download/\">https://nodejs.org/en/download/</a><br><img src=\"/../Img/20231016195905.png\" alt=\"下载\"></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>双击打开安装下一步下一步即可，我默认的路径是 </p>\n<blockquote>\n<p>C:\\Program Files\\nodejs</p>\n</blockquote>\n<h2 id=\"查看版本\"><a href=\"#查看版本\" class=\"headerlink\" title=\"查看版本\"></a>查看版本</h2><p>安装成功之后，运行<strong>cmd</strong><br>输入<strong>node -v</strong>和<strong>npm -v</strong>分别查看node和npm的版本。</p>\n<h1 id=\"npm安装全局模块的路径和缓存路径\"><a href=\"#npm安装全局模块的路径和缓存路径\" class=\"headerlink\" title=\"npm安装全局模块的路径和缓存路径\"></a>npm安装全局模块的路径和缓存路径</h1><p>在node.js的安装目录下新建文件夹分别为：</p>\n<blockquote>\n<p>node_global<br>node_cache</p>\n</blockquote>\n<p>创建完成之后在<strong>cmd</strong>中执行命令</p>\n<p><code>npm config set prefix &quot;C:\\Program Files\\nodejs\\node_global&quot;</code></p>\n<p><code>npm config set cache &quot;C:\\Program Files\\nodejs\\node_cache&quot;</code></p>\n<p><strong>设置完成之后进行环境变量的配置分别为:</strong></p>\n<p><code> “环境变量”&gt;“系统变量”：新建一个变量名为“NODE_PATH”，值为“C:\\Program Files\\nodejs\\node_global”</code></p>\n<p><code> “环境变量”&gt;“系统变量”：编辑系统里的path，添加 %NODE_PATH%</code></p>\n<p><code>“环境变量”&gt;“用户变量”：编辑用户变量里的path，相应npm的路径C:\\Program Files\\nodejs\\node_global</code></p>\n<p>配置完成之后，测试npm下载即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Nodejs安装\"><a href=\"#Nodejs安装\" class=\"headerlink\" title=\"Nodejs安装\"></a>Nodejs安装</h1><h2 id=\"下载Node-js\"><a href=\"#下载Node-js\" class=\"headerlink\" title=\"下载Node.js\"></a>下载Node.js</h2><p>Node.js 官方网站下载：<a href=\"https://nodejs.org/en/download/\">https://nodejs.org/en/download/</a><br><img src=\"/../Img/20231016195905.png\" alt=\"下载\"></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>双击打开安装下一步下一步即可，我默认的路径是 </p>\n<blockquote>\n<p>C:\\Program Files\\nodejs</p>\n</blockquote>\n<h2 id=\"查看版本\"><a href=\"#查看版本\" class=\"headerlink\" title=\"查看版本\"></a>查看版本</h2><p>安装成功之后，运行<strong>cmd</strong><br>输入<strong>node -v</strong>和<strong>npm -v</strong>分别查看node和npm的版本。</p>\n<h1 id=\"npm安装全局模块的路径和缓存路径\"><a href=\"#npm安装全局模块的路径和缓存路径\" class=\"headerlink\" title=\"npm安装全局模块的路径和缓存路径\"></a>npm安装全局模块的路径和缓存路径</h1><p>在node.js的安装目录下新建文件夹分别为：</p>\n<blockquote>\n<p>node_global<br>node_cache</p>\n</blockquote>\n<p>创建完成之后在<strong>cmd</strong>中执行命令</p>\n<p><code>npm config set prefix &quot;C:\\Program Files\\nodejs\\node_global&quot;</code></p>\n<p><code>npm config set cache &quot;C:\\Program Files\\nodejs\\node_cache&quot;</code></p>\n<p><strong>设置完成之后进行环境变量的配置分别为:</strong></p>\n<p><code> “环境变量”&gt;“系统变量”：新建一个变量名为“NODE_PATH”，值为“C:\\Program Files\\nodejs\\node_global”</code></p>\n<p><code> “环境变量”&gt;“系统变量”：编辑系统里的path，添加 %NODE_PATH%</code></p>\n<p><code>“环境变量”&gt;“用户变量”：编辑用户变量里的path，相应npm的路径C:\\Program Files\\nodejs\\node_global</code></p>\n<p>配置完成之后，测试npm下载即可。</p>\n"},{"title":"什么是HTTP？王老师与小明的编程故事","date":"2023-11-28T11:44:09.000Z","_content":"# 什么是HTTP\n一个放学后的午后。\n\n**小明**： 😯王老师你知道HTTP是什么吗？\n\n**王老师**：HTTP呀，HTTP是超文本传输协议缩写，它是用来在网络上传输信息的一种规则。\n\n**小明**： 搜噶，那它是怎么工作的呀？\n\n\n**王老师**：它就像一种沟通的语言，当你在浏览器里输入一个网址按下回车时，浏览器就会向服务发送一个HTTP请求，请求这个网页的内容。\n\n**小明**： 然后呢？\n\n**王老师**：然后服务器接受到这个请求后，会把网页的内容打包成HTTP响应，再发送回你的浏览器，这样你就能够看到网页上的信息和图像了。\n\n**小明**： 哦，原来这样啊，HTTP就是让我们能在网上看到各种网页内容的东西了。\n\n**王老师**：是的呀，当然HTTP还有些特点，比如它是无状态协议。\n\n**小明**：啊？什么意思？\n\n**王老师**：这意味着每次服务器收到请求时候，并不会记得之前和客户端的通信历史，每个请求都是独立的，服务器不会保存之前的状态信息。\n\n**小明**：那岂不是很不方便，我再网上填写的表单，下一步怎么知道之前填写的什么。\n\n**王老师**：是的，这就需求借助一些其他机制了，比如使用Cookie或者Session，今天就说HTTP。这个之后再给你讲。\n\n**小明**：那我还听说过TCP和HTTP，这几个P是不是都一种的呢？\n\n**王老师**：（😏震惊，p可还行）HTTP依赖TCP来传输数据的，当你发送HTTP请求时，它会封装到TCP包里，然后通过网络传输到服务器。\n\n**王老师**：TCP是一种传输协议，而HTTP是应用层协议，他们之间有一个重要联系就是在HTTP进行数据传输时依赖于TCP来建立可靠的传输通道，那么他们有一个叫“🤝🤝🤝```三次握手```”的过程建立连接。\n\n\n**小明**：我去，这么复杂呢，```三次握手```是个什么操作呀。\n\n**王老师**：```三次握手```首先是客户端就你的那个谷歌浏览器访问网页，向服务器发送一个请求连接的数据包，这个过程叫做```SYN(同步)```。\n\n**小明**：然后呢？\n\n**王老师**：然后服务器收到SYN后，会回复一个确认连接的数据包，同时会向客户端发送一个SYN，这个过程叫```SYN-ACK(同步-确认)```。\n\n**小明**：最后一步呢？\n\n**王老师**：客户端收到服务器端回复后，会再次向服务器发送一个确认连接的数据，这个过程叫做```ACK(确认)```。这样，三次握手完成，建立连接成功。\n\n**小明**：明白了，通过这个三次握手，客户端和服务器建立了一个可靠的连接，然后才能进行HTTP数据的传输。\n\n于是小明熬夜把HTTP详细了解了一遍。\n\n# HTTP/0.9 - One Liner (1991)\n\nHTTP的第一个有记录的版本是1991年提出的HTTP/0.9。有史以来最简单的协议；有一个名为GET的方法、如果客户端访问服务器上的某个网页，他会发出以下请求。\n```GET /index.html```\n那么服务器端响应如下所示\n```(response body)```\n```((connection closed))```\n服务器收到请求，回复HTML作为响应，一旦内容传输完毕，连接就会关闭。\n\n# HTTP/1.0 - 1996 年\n1996年 HTTP/1.0比原来的版本有很大的改进。现在可以处理响应格式有```图像```，```视频文件```，```纯文本```和其他内容类型。添加了POST和HEAD方法，更改了请求和响应格式。将HTTP标头添加到请求和响应中，添加了状态代码来标识和响应。\n以下是请求和响应的样子\n```GET / HTTP/1.0```\n```Host: cs.fyi```\n```User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)```\n```Accept: */* ```\n\n除了请求之外，客户端还发送了它的个人信息和所需要响应的类型等。\n\n{% codeblock lang:Http %}\n\nHTTP/1.0 200 OK \nContent-Type: text/plain\nContent-Length: 137582\nExpires: Thu, 05 Dec 1997 16:00:00 GMT\nLast-Modified: Wed, 5 August 1996 15:55:28 GMT\nServer: Apache 0.84\n\n(response body)\n(connection closed)\n\n{% endcodeblock %}\n响应的开头是HTTP/1.0(HTTP后跟版本号)、然后是状态代码200 后面原因短句OK。\n> 常见的状态码 **200**请求成功；**404**请求资源不存在；**500**服务器错误，无法完成请求。\n\nContent-Type ：MIME类型，告诉接收端应该如何解析该内容。\nContent-Length：主体的长度，字节单位。\n\n# HTTP/1.1-1999\n- 添加了新的HTTP方法，引入PUT、PATCH、OPTIONS、DELETE\n- 持久连接，在HTTP/1.0中，每个连接只有一个请求，一旦请求完成，连接就会关闭，这会有性能影响。HTTP/1.1引入持久连接，即连接默认情况下不会关闭，而是保持打开状态，从而允许多个顺序请求。要关闭连接，请求头Connection：close必须可用。客户端通常在最后一个请求中发送此标头以安全的关闭连接。\n\n- 管道化，客户端可以在同一个连接上向服务器发送多个请求，而无需等待服务器端响应，并且服务器必须按照请求的顺序发送响应。但是，客户端如何知道这是第一个响应下载完成并且下一个响应内容开始的点，为了解决这个问题，必须存在Content-Length标头，客户端可以使用它来识别响应结束的位置，并且可以开始等待下一个响应。\n\n# HTTP/2 - 2015\n\n到现在为止，您必须确信为什么我们需要对 HTTP 协议进行另一次修订。HTTP/2 专为低延迟内容传输而设计。与旧版本 HTTP/1.1 的主要功能或区别包括\n\n- 二进制而不是文本\n- 多路复用 - 单个连接上的多个异步 HTTP 请求\n- 使用 HPACK 进行标头压缩\n- 服务器推送 - 单个请求的多个响应\n- 请求优先级\n- 安全\n\n","source":"_posts/2.前端笔记/什么是HTTP.md","raw":"---\ntitle: 什么是HTTP？王老师与小明的编程故事\ndate: 2023-11-28 19:44:09\ntags: \n- HTTP\n- web开发\n---\n# 什么是HTTP\n一个放学后的午后。\n\n**小明**： 😯王老师你知道HTTP是什么吗？\n\n**王老师**：HTTP呀，HTTP是超文本传输协议缩写，它是用来在网络上传输信息的一种规则。\n\n**小明**： 搜噶，那它是怎么工作的呀？\n\n\n**王老师**：它就像一种沟通的语言，当你在浏览器里输入一个网址按下回车时，浏览器就会向服务发送一个HTTP请求，请求这个网页的内容。\n\n**小明**： 然后呢？\n\n**王老师**：然后服务器接受到这个请求后，会把网页的内容打包成HTTP响应，再发送回你的浏览器，这样你就能够看到网页上的信息和图像了。\n\n**小明**： 哦，原来这样啊，HTTP就是让我们能在网上看到各种网页内容的东西了。\n\n**王老师**：是的呀，当然HTTP还有些特点，比如它是无状态协议。\n\n**小明**：啊？什么意思？\n\n**王老师**：这意味着每次服务器收到请求时候，并不会记得之前和客户端的通信历史，每个请求都是独立的，服务器不会保存之前的状态信息。\n\n**小明**：那岂不是很不方便，我再网上填写的表单，下一步怎么知道之前填写的什么。\n\n**王老师**：是的，这就需求借助一些其他机制了，比如使用Cookie或者Session，今天就说HTTP。这个之后再给你讲。\n\n**小明**：那我还听说过TCP和HTTP，这几个P是不是都一种的呢？\n\n**王老师**：（😏震惊，p可还行）HTTP依赖TCP来传输数据的，当你发送HTTP请求时，它会封装到TCP包里，然后通过网络传输到服务器。\n\n**王老师**：TCP是一种传输协议，而HTTP是应用层协议，他们之间有一个重要联系就是在HTTP进行数据传输时依赖于TCP来建立可靠的传输通道，那么他们有一个叫“🤝🤝🤝```三次握手```”的过程建立连接。\n\n\n**小明**：我去，这么复杂呢，```三次握手```是个什么操作呀。\n\n**王老师**：```三次握手```首先是客户端就你的那个谷歌浏览器访问网页，向服务器发送一个请求连接的数据包，这个过程叫做```SYN(同步)```。\n\n**小明**：然后呢？\n\n**王老师**：然后服务器收到SYN后，会回复一个确认连接的数据包，同时会向客户端发送一个SYN，这个过程叫```SYN-ACK(同步-确认)```。\n\n**小明**：最后一步呢？\n\n**王老师**：客户端收到服务器端回复后，会再次向服务器发送一个确认连接的数据，这个过程叫做```ACK(确认)```。这样，三次握手完成，建立连接成功。\n\n**小明**：明白了，通过这个三次握手，客户端和服务器建立了一个可靠的连接，然后才能进行HTTP数据的传输。\n\n于是小明熬夜把HTTP详细了解了一遍。\n\n# HTTP/0.9 - One Liner (1991)\n\nHTTP的第一个有记录的版本是1991年提出的HTTP/0.9。有史以来最简单的协议；有一个名为GET的方法、如果客户端访问服务器上的某个网页，他会发出以下请求。\n```GET /index.html```\n那么服务器端响应如下所示\n```(response body)```\n```((connection closed))```\n服务器收到请求，回复HTML作为响应，一旦内容传输完毕，连接就会关闭。\n\n# HTTP/1.0 - 1996 年\n1996年 HTTP/1.0比原来的版本有很大的改进。现在可以处理响应格式有```图像```，```视频文件```，```纯文本```和其他内容类型。添加了POST和HEAD方法，更改了请求和响应格式。将HTTP标头添加到请求和响应中，添加了状态代码来标识和响应。\n以下是请求和响应的样子\n```GET / HTTP/1.0```\n```Host: cs.fyi```\n```User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)```\n```Accept: */* ```\n\n除了请求之外，客户端还发送了它的个人信息和所需要响应的类型等。\n\n{% codeblock lang:Http %}\n\nHTTP/1.0 200 OK \nContent-Type: text/plain\nContent-Length: 137582\nExpires: Thu, 05 Dec 1997 16:00:00 GMT\nLast-Modified: Wed, 5 August 1996 15:55:28 GMT\nServer: Apache 0.84\n\n(response body)\n(connection closed)\n\n{% endcodeblock %}\n响应的开头是HTTP/1.0(HTTP后跟版本号)、然后是状态代码200 后面原因短句OK。\n> 常见的状态码 **200**请求成功；**404**请求资源不存在；**500**服务器错误，无法完成请求。\n\nContent-Type ：MIME类型，告诉接收端应该如何解析该内容。\nContent-Length：主体的长度，字节单位。\n\n# HTTP/1.1-1999\n- 添加了新的HTTP方法，引入PUT、PATCH、OPTIONS、DELETE\n- 持久连接，在HTTP/1.0中，每个连接只有一个请求，一旦请求完成，连接就会关闭，这会有性能影响。HTTP/1.1引入持久连接，即连接默认情况下不会关闭，而是保持打开状态，从而允许多个顺序请求。要关闭连接，请求头Connection：close必须可用。客户端通常在最后一个请求中发送此标头以安全的关闭连接。\n\n- 管道化，客户端可以在同一个连接上向服务器发送多个请求，而无需等待服务器端响应，并且服务器必须按照请求的顺序发送响应。但是，客户端如何知道这是第一个响应下载完成并且下一个响应内容开始的点，为了解决这个问题，必须存在Content-Length标头，客户端可以使用它来识别响应结束的位置，并且可以开始等待下一个响应。\n\n# HTTP/2 - 2015\n\n到现在为止，您必须确信为什么我们需要对 HTTP 协议进行另一次修订。HTTP/2 专为低延迟内容传输而设计。与旧版本 HTTP/1.1 的主要功能或区别包括\n\n- 二进制而不是文本\n- 多路复用 - 单个连接上的多个异步 HTTP 请求\n- 使用 HPACK 进行标头压缩\n- 服务器推送 - 单个请求的多个响应\n- 请求优先级\n- 安全\n\n","slug":"2.前端笔记/什么是HTTP","published":1,"updated":"2023-11-28T12:59:06.405Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqr000ljkglh3cr1jr2","content":"<h1 id=\"什么是HTTP\"><a href=\"#什么是HTTP\" class=\"headerlink\" title=\"什么是HTTP\"></a>什么是HTTP</h1><p>一个放学后的午后。</p>\n<p><strong>小明</strong>： 😯王老师你知道HTTP是什么吗？</p>\n<p><strong>王老师</strong>：HTTP呀，HTTP是超文本传输协议缩写，它是用来在网络上传输信息的一种规则。</p>\n<p><strong>小明</strong>： 搜噶，那它是怎么工作的呀？</p>\n<p><strong>王老师</strong>：它就像一种沟通的语言，当你在浏览器里输入一个网址按下回车时，浏览器就会向服务发送一个HTTP请求，请求这个网页的内容。</p>\n<p><strong>小明</strong>： 然后呢？</p>\n<p><strong>王老师</strong>：然后服务器接受到这个请求后，会把网页的内容打包成HTTP响应，再发送回你的浏览器，这样你就能够看到网页上的信息和图像了。</p>\n<p><strong>小明</strong>： 哦，原来这样啊，HTTP就是让我们能在网上看到各种网页内容的东西了。</p>\n<p><strong>王老师</strong>：是的呀，当然HTTP还有些特点，比如它是无状态协议。</p>\n<p><strong>小明</strong>：啊？什么意思？</p>\n<p><strong>王老师</strong>：这意味着每次服务器收到请求时候，并不会记得之前和客户端的通信历史，每个请求都是独立的，服务器不会保存之前的状态信息。</p>\n<p><strong>小明</strong>：那岂不是很不方便，我再网上填写的表单，下一步怎么知道之前填写的什么。</p>\n<p><strong>王老师</strong>：是的，这就需求借助一些其他机制了，比如使用Cookie或者Session，今天就说HTTP。这个之后再给你讲。</p>\n<p><strong>小明</strong>：那我还听说过TCP和HTTP，这几个P是不是都一种的呢？</p>\n<p><strong>王老师</strong>：（😏震惊，p可还行）HTTP依赖TCP来传输数据的，当你发送HTTP请求时，它会封装到TCP包里，然后通过网络传输到服务器。</p>\n<p><strong>王老师</strong>：TCP是一种传输协议，而HTTP是应用层协议，他们之间有一个重要联系就是在HTTP进行数据传输时依赖于TCP来建立可靠的传输通道，那么他们有一个叫“🤝🤝🤝<code>三次握手</code>”的过程建立连接。</p>\n<p><strong>小明</strong>：我去，这么复杂呢，<code>三次握手</code>是个什么操作呀。</p>\n<p><strong>王老师</strong>：<code>三次握手</code>首先是客户端就你的那个谷歌浏览器访问网页，向服务器发送一个请求连接的数据包，这个过程叫做<code>SYN(同步)</code>。</p>\n<p><strong>小明</strong>：然后呢？</p>\n<p><strong>王老师</strong>：然后服务器收到SYN后，会回复一个确认连接的数据包，同时会向客户端发送一个SYN，这个过程叫<code>SYN-ACK(同步-确认)</code>。</p>\n<p><strong>小明</strong>：最后一步呢？</p>\n<p><strong>王老师</strong>：客户端收到服务器端回复后，会再次向服务器发送一个确认连接的数据，这个过程叫做<code>ACK(确认)</code>。这样，三次握手完成，建立连接成功。</p>\n<p><strong>小明</strong>：明白了，通过这个三次握手，客户端和服务器建立了一个可靠的连接，然后才能进行HTTP数据的传输。</p>\n<p>于是小明熬夜把HTTP详细了解了一遍。</p>\n<h1 id=\"HTTP-0-9-One-Liner-1991\"><a href=\"#HTTP-0-9-One-Liner-1991\" class=\"headerlink\" title=\"HTTP&#x2F;0.9 - One Liner (1991)\"></a>HTTP&#x2F;0.9 - One Liner (1991)</h1><p>HTTP的第一个有记录的版本是1991年提出的HTTP&#x2F;0.9。有史以来最简单的协议；有一个名为GET的方法、如果客户端访问服务器上的某个网页，他会发出以下请求。<br><code>GET /index.html</code><br>那么服务器端响应如下所示<br><code>(response body)</code><br><code>((connection closed))</code><br>服务器收到请求，回复HTML作为响应，一旦内容传输完毕，连接就会关闭。</p>\n<h1 id=\"HTTP-1-0-1996-年\"><a href=\"#HTTP-1-0-1996-年\" class=\"headerlink\" title=\"HTTP&#x2F;1.0 - 1996 年\"></a>HTTP&#x2F;1.0 - 1996 年</h1><p>1996年 HTTP&#x2F;1.0比原来的版本有很大的改进。现在可以处理响应格式有<code>图像</code>，<code>视频文件</code>，<code>纯文本</code>和其他内容类型。添加了POST和HEAD方法，更改了请求和响应格式。将HTTP标头添加到请求和响应中，添加了状态代码来标识和响应。<br>以下是请求和响应的样子<br><code>GET / HTTP/1.0</code><br><code>Host: cs.fyi</code><br><code>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</code><br><code>Accept: */* </code></p>\n<p>除了请求之外，客户端还发送了它的个人信息和所需要响应的类型等。</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">HTTP/1.0</span> <span class=\"number\">200</span> OK </span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>text/plain</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span><span class=\"punctuation\">: </span>137582</span><br><span class=\"line\"><span class=\"attribute\">Expires</span><span class=\"punctuation\">: </span>Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class=\"line\"><span class=\"attribute\">Last-Modified</span><span class=\"punctuation\">: </span>Wed, 5 August 1996 15:55:28 GMT</span><br><span class=\"line\"><span class=\"attribute\">Server</span><span class=\"punctuation\">: </span>Apache 0.84</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-clojure\">(<span class=\"name\">response</span> body)</span></span><br><span class=\"line\"><span class=\"language-clojure\">(<span class=\"name\">connection</span> closed)</span></span><br><span class=\"line\"><span class=\"language-clojure\"></span></span><br></pre></td></tr></table></figure>\n<p>响应的开头是HTTP&#x2F;1.0(HTTP后跟版本号)、然后是状态代码200 后面原因短句OK。</p>\n<blockquote>\n<p>常见的状态码 <strong>200</strong>请求成功；<strong>404</strong>请求资源不存在；<strong>500</strong>服务器错误，无法完成请求。</p>\n</blockquote>\n<p>Content-Type ：MIME类型，告诉接收端应该如何解析该内容。<br>Content-Length：主体的长度，字节单位。</p>\n<h1 id=\"HTTP-1-1-1999\"><a href=\"#HTTP-1-1-1999\" class=\"headerlink\" title=\"HTTP&#x2F;1.1-1999\"></a>HTTP&#x2F;1.1-1999</h1><ul>\n<li><p>添加了新的HTTP方法，引入PUT、PATCH、OPTIONS、DELETE</p>\n</li>\n<li><p>持久连接，在HTTP&#x2F;1.0中，每个连接只有一个请求，一旦请求完成，连接就会关闭，这会有性能影响。HTTP&#x2F;1.1引入持久连接，即连接默认情况下不会关闭，而是保持打开状态，从而允许多个顺序请求。要关闭连接，请求头Connection：close必须可用。客户端通常在最后一个请求中发送此标头以安全的关闭连接。</p>\n</li>\n<li><p>管道化，客户端可以在同一个连接上向服务器发送多个请求，而无需等待服务器端响应，并且服务器必须按照请求的顺序发送响应。但是，客户端如何知道这是第一个响应下载完成并且下一个响应内容开始的点，为了解决这个问题，必须存在Content-Length标头，客户端可以使用它来识别响应结束的位置，并且可以开始等待下一个响应。</p>\n</li>\n</ul>\n<h1 id=\"HTTP-2-2015\"><a href=\"#HTTP-2-2015\" class=\"headerlink\" title=\"HTTP&#x2F;2 - 2015\"></a>HTTP&#x2F;2 - 2015</h1><p>到现在为止，您必须确信为什么我们需要对 HTTP 协议进行另一次修订。HTTP&#x2F;2 专为低延迟内容传输而设计。与旧版本 HTTP&#x2F;1.1 的主要功能或区别包括</p>\n<ul>\n<li>二进制而不是文本</li>\n<li>多路复用 - 单个连接上的多个异步 HTTP 请求</li>\n<li>使用 HPACK 进行标头压缩</li>\n<li>服务器推送 - 单个请求的多个响应</li>\n<li>请求优先级</li>\n<li>安全</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是HTTP\"><a href=\"#什么是HTTP\" class=\"headerlink\" title=\"什么是HTTP\"></a>什么是HTTP</h1><p>一个放学后的午后。</p>\n<p><strong>小明</strong>： 😯王老师你知道HTTP是什么吗？</p>\n<p><strong>王老师</strong>：HTTP呀，HTTP是超文本传输协议缩写，它是用来在网络上传输信息的一种规则。</p>\n<p><strong>小明</strong>： 搜噶，那它是怎么工作的呀？</p>\n<p><strong>王老师</strong>：它就像一种沟通的语言，当你在浏览器里输入一个网址按下回车时，浏览器就会向服务发送一个HTTP请求，请求这个网页的内容。</p>\n<p><strong>小明</strong>： 然后呢？</p>\n<p><strong>王老师</strong>：然后服务器接受到这个请求后，会把网页的内容打包成HTTP响应，再发送回你的浏览器，这样你就能够看到网页上的信息和图像了。</p>\n<p><strong>小明</strong>： 哦，原来这样啊，HTTP就是让我们能在网上看到各种网页内容的东西了。</p>\n<p><strong>王老师</strong>：是的呀，当然HTTP还有些特点，比如它是无状态协议。</p>\n<p><strong>小明</strong>：啊？什么意思？</p>\n<p><strong>王老师</strong>：这意味着每次服务器收到请求时候，并不会记得之前和客户端的通信历史，每个请求都是独立的，服务器不会保存之前的状态信息。</p>\n<p><strong>小明</strong>：那岂不是很不方便，我再网上填写的表单，下一步怎么知道之前填写的什么。</p>\n<p><strong>王老师</strong>：是的，这就需求借助一些其他机制了，比如使用Cookie或者Session，今天就说HTTP。这个之后再给你讲。</p>\n<p><strong>小明</strong>：那我还听说过TCP和HTTP，这几个P是不是都一种的呢？</p>\n<p><strong>王老师</strong>：（😏震惊，p可还行）HTTP依赖TCP来传输数据的，当你发送HTTP请求时，它会封装到TCP包里，然后通过网络传输到服务器。</p>\n<p><strong>王老师</strong>：TCP是一种传输协议，而HTTP是应用层协议，他们之间有一个重要联系就是在HTTP进行数据传输时依赖于TCP来建立可靠的传输通道，那么他们有一个叫“🤝🤝🤝<code>三次握手</code>”的过程建立连接。</p>\n<p><strong>小明</strong>：我去，这么复杂呢，<code>三次握手</code>是个什么操作呀。</p>\n<p><strong>王老师</strong>：<code>三次握手</code>首先是客户端就你的那个谷歌浏览器访问网页，向服务器发送一个请求连接的数据包，这个过程叫做<code>SYN(同步)</code>。</p>\n<p><strong>小明</strong>：然后呢？</p>\n<p><strong>王老师</strong>：然后服务器收到SYN后，会回复一个确认连接的数据包，同时会向客户端发送一个SYN，这个过程叫<code>SYN-ACK(同步-确认)</code>。</p>\n<p><strong>小明</strong>：最后一步呢？</p>\n<p><strong>王老师</strong>：客户端收到服务器端回复后，会再次向服务器发送一个确认连接的数据，这个过程叫做<code>ACK(确认)</code>。这样，三次握手完成，建立连接成功。</p>\n<p><strong>小明</strong>：明白了，通过这个三次握手，客户端和服务器建立了一个可靠的连接，然后才能进行HTTP数据的传输。</p>\n<p>于是小明熬夜把HTTP详细了解了一遍。</p>\n<h1 id=\"HTTP-0-9-One-Liner-1991\"><a href=\"#HTTP-0-9-One-Liner-1991\" class=\"headerlink\" title=\"HTTP&#x2F;0.9 - One Liner (1991)\"></a>HTTP&#x2F;0.9 - One Liner (1991)</h1><p>HTTP的第一个有记录的版本是1991年提出的HTTP&#x2F;0.9。有史以来最简单的协议；有一个名为GET的方法、如果客户端访问服务器上的某个网页，他会发出以下请求。<br><code>GET /index.html</code><br>那么服务器端响应如下所示<br><code>(response body)</code><br><code>((connection closed))</code><br>服务器收到请求，回复HTML作为响应，一旦内容传输完毕，连接就会关闭。</p>\n<h1 id=\"HTTP-1-0-1996-年\"><a href=\"#HTTP-1-0-1996-年\" class=\"headerlink\" title=\"HTTP&#x2F;1.0 - 1996 年\"></a>HTTP&#x2F;1.0 - 1996 年</h1><p>1996年 HTTP&#x2F;1.0比原来的版本有很大的改进。现在可以处理响应格式有<code>图像</code>，<code>视频文件</code>，<code>纯文本</code>和其他内容类型。添加了POST和HEAD方法，更改了请求和响应格式。将HTTP标头添加到请求和响应中，添加了状态代码来标识和响应。<br>以下是请求和响应的样子<br><code>GET / HTTP/1.0</code><br><code>Host: cs.fyi</code><br><code>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</code><br><code>Accept: */* </code></p>\n<p>除了请求之外，客户端还发送了它的个人信息和所需要响应的类型等。</p>\n<figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">HTTP/1.0</span> <span class=\"number\">200</span> OK </span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span><span class=\"punctuation\">: </span>text/plain</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span><span class=\"punctuation\">: </span>137582</span><br><span class=\"line\"><span class=\"attribute\">Expires</span><span class=\"punctuation\">: </span>Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class=\"line\"><span class=\"attribute\">Last-Modified</span><span class=\"punctuation\">: </span>Wed, 5 August 1996 15:55:28 GMT</span><br><span class=\"line\"><span class=\"attribute\">Server</span><span class=\"punctuation\">: </span>Apache 0.84</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"language-clojure\">(<span class=\"name\">response</span> body)</span></span><br><span class=\"line\"><span class=\"language-clojure\">(<span class=\"name\">connection</span> closed)</span></span><br><span class=\"line\"><span class=\"language-clojure\"></span></span><br></pre></td></tr></table></figure>\n<p>响应的开头是HTTP&#x2F;1.0(HTTP后跟版本号)、然后是状态代码200 后面原因短句OK。</p>\n<blockquote>\n<p>常见的状态码 <strong>200</strong>请求成功；<strong>404</strong>请求资源不存在；<strong>500</strong>服务器错误，无法完成请求。</p>\n</blockquote>\n<p>Content-Type ：MIME类型，告诉接收端应该如何解析该内容。<br>Content-Length：主体的长度，字节单位。</p>\n<h1 id=\"HTTP-1-1-1999\"><a href=\"#HTTP-1-1-1999\" class=\"headerlink\" title=\"HTTP&#x2F;1.1-1999\"></a>HTTP&#x2F;1.1-1999</h1><ul>\n<li><p>添加了新的HTTP方法，引入PUT、PATCH、OPTIONS、DELETE</p>\n</li>\n<li><p>持久连接，在HTTP&#x2F;1.0中，每个连接只有一个请求，一旦请求完成，连接就会关闭，这会有性能影响。HTTP&#x2F;1.1引入持久连接，即连接默认情况下不会关闭，而是保持打开状态，从而允许多个顺序请求。要关闭连接，请求头Connection：close必须可用。客户端通常在最后一个请求中发送此标头以安全的关闭连接。</p>\n</li>\n<li><p>管道化，客户端可以在同一个连接上向服务器发送多个请求，而无需等待服务器端响应，并且服务器必须按照请求的顺序发送响应。但是，客户端如何知道这是第一个响应下载完成并且下一个响应内容开始的点，为了解决这个问题，必须存在Content-Length标头，客户端可以使用它来识别响应结束的位置，并且可以开始等待下一个响应。</p>\n</li>\n</ul>\n<h1 id=\"HTTP-2-2015\"><a href=\"#HTTP-2-2015\" class=\"headerlink\" title=\"HTTP&#x2F;2 - 2015\"></a>HTTP&#x2F;2 - 2015</h1><p>到现在为止，您必须确信为什么我们需要对 HTTP 协议进行另一次修订。HTTP&#x2F;2 专为低延迟内容传输而设计。与旧版本 HTTP&#x2F;1.1 的主要功能或区别包括</p>\n<ul>\n<li>二进制而不是文本</li>\n<li>多路复用 - 单个连接上的多个异步 HTTP 请求</li>\n<li>使用 HPACK 进行标头压缩</li>\n<li>服务器推送 - 单个请求的多个响应</li>\n<li>请求优先级</li>\n<li>安全</li>\n</ul>\n"},{"title":"前端常用命令","date":"2019-02-07T03:12:11.000Z","_content":"# 查看当前本地npm配置的仓库镜像\nnpm get registry\n或者查询当前镜像源\nnpm config get registry\n\n# 旧版本的npm通过npm命令来升级\nnpm install npm -g\n# 设置为淘宝镜像\nnpm config set registry https://registry.npmmirror.com\n\n# 设置回默认的官方镜像\nnpm config set registry https://registry.npmjs.org/\n#　设置electron淘宝镜像\nnpm config set ELECTRON_MIRROR \"https://npm.taobao.org/mirrors/electron/\"\n\n# 查看和删除electron淘宝镜像设置：\nnpm config get ELECTRON_MIRROR\nnpm config delete ELECTRON_MIRROR\n\n# 使用cnpm命令替换npm命令\n\nnpm install -g cnpm  --registry=https://registry.npm.taobao.org\n\ncnpm install npm@7.18.1 -g  // 利用cnpm安装指定版本\n\n# nvm常用命令\n- nvm -v 查看版本\n- nvm list 查看已按照版本\n- nvm list available 查看所有可安装版本\n- nvm install 18.14.0 安装指定版本\n- nvm uninstall 18.14.0 卸载指定版本\n- nvm use 18.14.0 切换使用指定版本node\n- nvm root 显示nvm安装目录\n\n# 常见错误\n\n\n- Command vue init requires a global addon to be installed.\n  Please run undefined @vue/cli-init and try again.\n> 原因：没有安装init依赖:npm install -g @vue/cli-init \n\n","source":"_posts/2.前端笔记/前端常用命令.md","raw":"---\ntitle: 前端常用命令\ndate: 2019-02-07 11:12:11\ncategories: 前端笔记\ntags: \n- 前端常用命令\n- npm\n---\n# 查看当前本地npm配置的仓库镜像\nnpm get registry\n或者查询当前镜像源\nnpm config get registry\n\n# 旧版本的npm通过npm命令来升级\nnpm install npm -g\n# 设置为淘宝镜像\nnpm config set registry https://registry.npmmirror.com\n\n# 设置回默认的官方镜像\nnpm config set registry https://registry.npmjs.org/\n#　设置electron淘宝镜像\nnpm config set ELECTRON_MIRROR \"https://npm.taobao.org/mirrors/electron/\"\n\n# 查看和删除electron淘宝镜像设置：\nnpm config get ELECTRON_MIRROR\nnpm config delete ELECTRON_MIRROR\n\n# 使用cnpm命令替换npm命令\n\nnpm install -g cnpm  --registry=https://registry.npm.taobao.org\n\ncnpm install npm@7.18.1 -g  // 利用cnpm安装指定版本\n\n# nvm常用命令\n- nvm -v 查看版本\n- nvm list 查看已按照版本\n- nvm list available 查看所有可安装版本\n- nvm install 18.14.0 安装指定版本\n- nvm uninstall 18.14.0 卸载指定版本\n- nvm use 18.14.0 切换使用指定版本node\n- nvm root 显示nvm安装目录\n\n# 常见错误\n\n\n- Command vue init requires a global addon to be installed.\n  Please run undefined @vue/cli-init and try again.\n> 原因：没有安装init依赖:npm install -g @vue/cli-init \n\n","slug":"2.前端笔记/前端常用命令","published":1,"updated":"2023-12-23T02:19:25.926Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqr000njkgl943d7nki","content":"<h1 id=\"查看当前本地npm配置的仓库镜像\"><a href=\"#查看当前本地npm配置的仓库镜像\" class=\"headerlink\" title=\"查看当前本地npm配置的仓库镜像\"></a>查看当前本地npm配置的仓库镜像</h1><p>npm get registry<br>或者查询当前镜像源<br>npm config get registry</p>\n<h1 id=\"旧版本的npm通过npm命令来升级\"><a href=\"#旧版本的npm通过npm命令来升级\" class=\"headerlink\" title=\"旧版本的npm通过npm命令来升级\"></a>旧版本的npm通过npm命令来升级</h1><p>npm install npm -g</p>\n<h1 id=\"设置为淘宝镜像\"><a href=\"#设置为淘宝镜像\" class=\"headerlink\" title=\"设置为淘宝镜像\"></a>设置为淘宝镜像</h1><p>npm config set registry <a href=\"https://registry.npmmirror.com/\">https://registry.npmmirror.com</a></p>\n<h1 id=\"设置回默认的官方镜像\"><a href=\"#设置回默认的官方镜像\" class=\"headerlink\" title=\"设置回默认的官方镜像\"></a>设置回默认的官方镜像</h1><p>npm config set registry <a href=\"https://registry.npmjs.org/\">https://registry.npmjs.org/</a><br>#　设置electron淘宝镜像<br>npm config set ELECTRON_MIRROR “<a href=\"https://npm.taobao.org/mirrors/electron/\">https://npm.taobao.org/mirrors/electron/</a>“</p>\n<h1 id=\"查看和删除electron淘宝镜像设置：\"><a href=\"#查看和删除electron淘宝镜像设置：\" class=\"headerlink\" title=\"查看和删除electron淘宝镜像设置：\"></a>查看和删除electron淘宝镜像设置：</h1><p>npm config get ELECTRON_MIRROR<br>npm config delete ELECTRON_MIRROR</p>\n<h1 id=\"使用cnpm命令替换npm命令\"><a href=\"#使用cnpm命令替换npm命令\" class=\"headerlink\" title=\"使用cnpm命令替换npm命令\"></a>使用cnpm命令替换npm命令</h1><p>npm install -g cnpm  –registry&#x3D;<a href=\"https://registry.npm.taobao.org/\">https://registry.npm.taobao.org</a></p>\n<p>cnpm install <a href=\"mailto:&#x6e;&#x70;&#x6d;&#x40;&#x37;&#46;&#x31;&#x38;&#46;&#49;\">&#x6e;&#x70;&#x6d;&#x40;&#x37;&#46;&#x31;&#x38;&#46;&#49;</a> -g  &#x2F;&#x2F; 利用cnpm安装指定版本</p>\n<h1 id=\"nvm常用命令\"><a href=\"#nvm常用命令\" class=\"headerlink\" title=\"nvm常用命令\"></a>nvm常用命令</h1><ul>\n<li>nvm -v 查看版本</li>\n<li>nvm list 查看已按照版本</li>\n<li>nvm list available 查看所有可安装版本</li>\n<li>nvm install 18.14.0 安装指定版本</li>\n<li>nvm uninstall 18.14.0 卸载指定版本</li>\n<li>nvm use 18.14.0 切换使用指定版本node</li>\n<li>nvm root 显示nvm安装目录</li>\n</ul>\n<h1 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h1><ul>\n<li>Command vue init requires a global addon to be installed.<br>Please run undefined @vue&#x2F;cli-init and try again.<blockquote>\n<p>原因：没有安装init依赖:npm install -g @vue&#x2F;cli-init</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"查看当前本地npm配置的仓库镜像\"><a href=\"#查看当前本地npm配置的仓库镜像\" class=\"headerlink\" title=\"查看当前本地npm配置的仓库镜像\"></a>查看当前本地npm配置的仓库镜像</h1><p>npm get registry<br>或者查询当前镜像源<br>npm config get registry</p>\n<h1 id=\"旧版本的npm通过npm命令来升级\"><a href=\"#旧版本的npm通过npm命令来升级\" class=\"headerlink\" title=\"旧版本的npm通过npm命令来升级\"></a>旧版本的npm通过npm命令来升级</h1><p>npm install npm -g</p>\n<h1 id=\"设置为淘宝镜像\"><a href=\"#设置为淘宝镜像\" class=\"headerlink\" title=\"设置为淘宝镜像\"></a>设置为淘宝镜像</h1><p>npm config set registry <a href=\"https://registry.npmmirror.com/\">https://registry.npmmirror.com</a></p>\n<h1 id=\"设置回默认的官方镜像\"><a href=\"#设置回默认的官方镜像\" class=\"headerlink\" title=\"设置回默认的官方镜像\"></a>设置回默认的官方镜像</h1><p>npm config set registry <a href=\"https://registry.npmjs.org/\">https://registry.npmjs.org/</a><br>#　设置electron淘宝镜像<br>npm config set ELECTRON_MIRROR “<a href=\"https://npm.taobao.org/mirrors/electron/\">https://npm.taobao.org/mirrors/electron/</a>“</p>\n<h1 id=\"查看和删除electron淘宝镜像设置：\"><a href=\"#查看和删除electron淘宝镜像设置：\" class=\"headerlink\" title=\"查看和删除electron淘宝镜像设置：\"></a>查看和删除electron淘宝镜像设置：</h1><p>npm config get ELECTRON_MIRROR<br>npm config delete ELECTRON_MIRROR</p>\n<h1 id=\"使用cnpm命令替换npm命令\"><a href=\"#使用cnpm命令替换npm命令\" class=\"headerlink\" title=\"使用cnpm命令替换npm命令\"></a>使用cnpm命令替换npm命令</h1><p>npm install -g cnpm  –registry&#x3D;<a href=\"https://registry.npm.taobao.org/\">https://registry.npm.taobao.org</a></p>\n<p>cnpm install <a href=\"mailto:&#x6e;&#x70;&#x6d;&#x40;&#x37;&#46;&#x31;&#x38;&#46;&#49;\">&#x6e;&#x70;&#x6d;&#x40;&#x37;&#46;&#x31;&#x38;&#46;&#49;</a> -g  &#x2F;&#x2F; 利用cnpm安装指定版本</p>\n<h1 id=\"nvm常用命令\"><a href=\"#nvm常用命令\" class=\"headerlink\" title=\"nvm常用命令\"></a>nvm常用命令</h1><ul>\n<li>nvm -v 查看版本</li>\n<li>nvm list 查看已按照版本</li>\n<li>nvm list available 查看所有可安装版本</li>\n<li>nvm install 18.14.0 安装指定版本</li>\n<li>nvm uninstall 18.14.0 卸载指定版本</li>\n<li>nvm use 18.14.0 切换使用指定版本node</li>\n<li>nvm root 显示nvm安装目录</li>\n</ul>\n<h1 id=\"常见错误\"><a href=\"#常见错误\" class=\"headerlink\" title=\"常见错误\"></a>常见错误</h1><ul>\n<li>Command vue init requires a global addon to be installed.<br>Please run undefined @vue&#x2F;cli-init and try again.<blockquote>\n<p>原因：没有安装init依赖:npm install -g @vue&#x2F;cli-init</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"1.Net Core的NET Standard","date":"2022-02-08T16:30:00.000Z","_content":"\n# .NET Standard\n.NET Standard是.NET Framework和.NET Core的一个标准和规范，主要包含如String或一些基础类，不提供实现。\n- 只有定义没有实现\n- 在不同的.NET实现中运行，包括.NET Framework、.NET Core和.NET 5\n\n\n\n\n\n","source":"_posts/3.后端笔记/1.Net Core的NET Standard.md","raw":"---\ntitle: 1.Net Core的NET Standard\ndate: 2022-02-09 00:30:00\ncategories: 后端笔记\ntags: \n- C#\n- .Net Core\n---\n\n# .NET Standard\n.NET Standard是.NET Framework和.NET Core的一个标准和规范，主要包含如String或一些基础类，不提供实现。\n- 只有定义没有实现\n- 在不同的.NET实现中运行，包括.NET Framework、.NET Core和.NET 5\n\n\n\n\n\n","slug":"3.后端笔记/1.Net Core的NET Standard","published":1,"updated":"2023-10-23T11:10:44.512Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqt000qjkgl7sftdrdl","content":"<h1 id=\"NET-Standard\"><a href=\"#NET-Standard\" class=\"headerlink\" title=\".NET Standard\"></a>.NET Standard</h1><p>.NET Standard是.NET Framework和.NET Core的一个标准和规范，主要包含如String或一些基础类，不提供实现。</p>\n<ul>\n<li>只有定义没有实现</li>\n<li>在不同的.NET实现中运行，包括.NET Framework、.NET Core和.NET 5</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"NET-Standard\"><a href=\"#NET-Standard\" class=\"headerlink\" title=\".NET Standard\"></a>.NET Standard</h1><p>.NET Standard是.NET Framework和.NET Core的一个标准和规范，主要包含如String或一些基础类，不提供实现。</p>\n<ul>\n<li>只有定义没有实现</li>\n<li>在不同的.NET实现中运行，包括.NET Framework、.NET Core和.NET 5</li>\n</ul>\n"},{"title":"2.Net Core使用NET CLI","date":"2022-02-12T11:00:40.000Z","_content":"# 什么是.NET CLI\n.NET CLI是一组命令行工具，用于创建、构建、运行和管理.NET应用程序。工具允许开发者在终端窗口中执行.NET的开发任务，构建、包管理、测试和发布应用程序。主要可以跨平台，可以在Windows、macOS和Linux上运行\n> **官方文档地址：https://learn.microsoft.com/zh-cn/dotnet/core/tools/**\n\n# 创建应用程序\n> 首先确保已经安装.NET SDK\n\n> 然后打开命令终端，如**cmd，PowerShell**。\n\n> 输入以下内容：\n{% codeblock lang:PowerShell %}\ndotnet new console -o test \ncd test\ndotnet run\n{% endcodeblock %}\n该命令主要创建一个新的.NET控制台应用程序项目，命名为**test**","source":"_posts/3.后端笔记/2.Net Core 使用NET CLI.md","raw":"---\ntitle: 2.Net Core使用NET CLI\ndate: 2022-02-12 19:00:40\ncategories: 后端笔记\ntags: \n- C#\n- .Net Core\n---\n# 什么是.NET CLI\n.NET CLI是一组命令行工具，用于创建、构建、运行和管理.NET应用程序。工具允许开发者在终端窗口中执行.NET的开发任务，构建、包管理、测试和发布应用程序。主要可以跨平台，可以在Windows、macOS和Linux上运行\n> **官方文档地址：https://learn.microsoft.com/zh-cn/dotnet/core/tools/**\n\n# 创建应用程序\n> 首先确保已经安装.NET SDK\n\n> 然后打开命令终端，如**cmd，PowerShell**。\n\n> 输入以下内容：\n{% codeblock lang:PowerShell %}\ndotnet new console -o test \ncd test\ndotnet run\n{% endcodeblock %}\n该命令主要创建一个新的.NET控制台应用程序项目，命名为**test**","slug":"3.后端笔记/2.Net Core 使用NET CLI","published":1,"updated":"2023-10-23T11:10:41.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqu000sjkgl8ok85zav","content":"<h1 id=\"什么是-NET-CLI\"><a href=\"#什么是-NET-CLI\" class=\"headerlink\" title=\"什么是.NET CLI\"></a>什么是.NET CLI</h1><p>.NET CLI是一组命令行工具，用于创建、构建、运行和管理.NET应用程序。工具允许开发者在终端窗口中执行.NET的开发任务，构建、包管理、测试和发布应用程序。主要可以跨平台，可以在Windows、macOS和Linux上运行</p>\n<blockquote>\n<p><strong>官方文档地址：<a href=\"https://learn.microsoft.com/zh-cn/dotnet/core/tools/\">https://learn.microsoft.com/zh-cn/dotnet/core/tools/</a></strong></p>\n</blockquote>\n<h1 id=\"创建应用程序\"><a href=\"#创建应用程序\" class=\"headerlink\" title=\"创建应用程序\"></a>创建应用程序</h1><blockquote>\n<p>首先确保已经安装.NET SDK</p>\n</blockquote>\n<blockquote>\n<p>然后打开命令终端，如<strong>cmd，PowerShell</strong>。</p>\n</blockquote>\n<blockquote>\n<p>输入以下内容：</p>\n</blockquote>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet new console <span class=\"literal\">-o</span> test </span><br><span class=\"line\"><span class=\"built_in\">cd</span> test</span><br><span class=\"line\">dotnet run</span><br></pre></td></tr></table></figure>\n<p>该命令主要创建一个新的.NET控制台应用程序项目，命名为<strong>test</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"什么是-NET-CLI\"><a href=\"#什么是-NET-CLI\" class=\"headerlink\" title=\"什么是.NET CLI\"></a>什么是.NET CLI</h1><p>.NET CLI是一组命令行工具，用于创建、构建、运行和管理.NET应用程序。工具允许开发者在终端窗口中执行.NET的开发任务，构建、包管理、测试和发布应用程序。主要可以跨平台，可以在Windows、macOS和Linux上运行</p>\n<blockquote>\n<p><strong>官方文档地址：<a href=\"https://learn.microsoft.com/zh-cn/dotnet/core/tools/\">https://learn.microsoft.com/zh-cn/dotnet/core/tools/</a></strong></p>\n</blockquote>\n<h1 id=\"创建应用程序\"><a href=\"#创建应用程序\" class=\"headerlink\" title=\"创建应用程序\"></a>创建应用程序</h1><blockquote>\n<p>首先确保已经安装.NET SDK</p>\n</blockquote>\n<blockquote>\n<p>然后打开命令终端，如<strong>cmd，PowerShell</strong>。</p>\n</blockquote>\n<blockquote>\n<p>输入以下内容：</p>\n</blockquote>\n<figure class=\"highlight powershell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dotnet new console <span class=\"literal\">-o</span> test </span><br><span class=\"line\"><span class=\"built_in\">cd</span> test</span><br><span class=\"line\">dotnet run</span><br></pre></td></tr></table></figure>\n<p>该命令主要创建一个新的.NET控制台应用程序项目，命名为<strong>test</strong></p>\n"},{"title":".Net扩展、库、工具、持续更新","date":"2023-12-02T06:00:40.000Z","_content":"# 库与框架\n## .Net系统框架\n### Avalonia - 跨平台 UI 框架\n> Avalonia是 dotnet 的跨平台 UI 框架，提供灵活的样式系统，支持 Windows、macOS、Linux、iOS、Android 和 WebAssembly 等多种平台。\n\n### Ant Design of Blazor \n> Blazor样板的企业应用程序的开箱即用 UI 解决方案\n\n## 容器注入\n\n### Autofac\n> Autofac是一个用于依赖注入（DI）和反转控制（IoC）的.NET库，提供了一个容器，用于注册、解析和管理应用程序中的组件，这些组件包括服务、对象和其他依赖项。\n\n\n### Prism - 框架库\n> Prism 是一个框架，用于在 WPF 和 Xamarin Forms 中构建松散耦合、可维护和可测试的 XAML 应用程序。每个平台都有单独的版本，并且这些版本将按照独立的时间表进行开发。Prism 提供了一系列设计模式的实现，这些设计模式有助于编写结构良好且可维护的 XAML 应用程序，包括 MVVM、依赖项注入、命令、EventAggregator 等。\n\n\n### CommunityToolkit.MVVM - MVVM 工具包\n> CommunityToolkit.MVVM是一个用于创建基于MVVM（Model-View-ViewModel）设计模式的应用程序的开源工具包，它是Microsoft的CommunityToolkit项目的一部分。这个工具包旨在帮助开发人员更容易地构建XAML应用程序。\n\n## 图表\n### LiveChartsCore.SkiaSharpView.WPF - 实时图表\n> LiveCharts 是一个.Net 数据可视化库，可以跨多个设备和框架运行。包含MAUI，AVALONIA，UNO PLATFORM， ETOFOROMS，XAMARIN，BLAZOR WASM，WPF。\n### SparrowToolkit \n> 一套WPF图表控件集，支持绘制动态曲线，可绘制示波器、CPU使用率和波形。\n## 文档操作\n### iTextSharp\n> iTextSharp是一个用于生成和操作PDF文档的C#库。它允许开发人员创建、读取、修改和分析PDF\n### QuestPDF - 生成 PDF 文档的现代开源 .NET 库\n> QuestPDF 是一个用于生成 PDF 文档的现代开源 .NET 库。它支持所有 .NET 平台，包括 .NET Framework、.\n\n### HtmlAgilityPack - 爬虫库\n> HtmlAgilityPack是一个基于.Net的、第三方免费开源的微型类库,主要用于在服务器端解析html文档。\n\n### NPOI - 工具库\n> 一个用于操作Microsoft Office文件格式的开源库。它允许开发人员在.NET平台上创建、读取和编辑Microsoft Excel（.xls和.xlsx）、Word和PowerPoint等文件格式。NPOI 提供了一种方便的方式来处理Office文档，以便在应用程序中进行数据导入、导出、报表生成等操作。\n\n## 通讯\n### SignalR - 通讯库\n> SignalR 是一个开源的.NET库，用于在实时应用程序中实现双向通信。它允许开发人员构建具有实时功能的应用程序，例如聊天应用、在线游戏、协作工具、股票市场更新、监控系统等。\n\n## 任务调度框架\n### Quartz.Net - 任务调度框架\n> 用于构建作业调度应用程序的.NET库。它支持多种存储类型，包括关系数据库、文件、MSMQ、RavenDB、SQLServer、Oracle、MySQL、PostgreSQL、SQLite、NoSQL等。\n### Hangfire - 任务调度框架\n> Hangfire 是一个开源的.NET库，用于在后台执行任务调度。\n### Topshelf\n> Topshelf 是一个开源的.NET库，用于构建Windows服务。它提供了一个简单的API，用于定义、安装和运行.NETWindows服务。\n\n## 分布式缓存框架\n### StackExchange.Redis - 分布式缓存框架\n> 用于构建分布式缓存系统的.NET客户端库。它支持Redis、Memcached、Couchbase和MongoDB等缓存系统\n### Memcahed -  分布式缓存框架\n> Memcached 是一个高性能、分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。\n\n## 中间件与消息队列\n### RabbitMQ\n> 基于 AMQP 协议，RabbitMQ 是一个开源的，由 Erlang 语言编写的，面向消息的中间件。\n### Redis \n> Redis 是一个开源的、内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。\n### Kafka/Jafka\n> Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。\n## 常用ORM框架\n### Dapper - 轻量级ORM框架\n> Dapper 是一个轻量级的ORM框架，它允许开发人员通过简单、一致和类型安全的API来访问数据库。\n### NHibernate - ORM框架\n> NHibernate 是一个开源的对象关系映射（ORM）框架，它允许开发人员使用面向对象的模型来操作关系数据库。\n### EntityFramework - ORM框架\n> 微软的Entity Framework 是一个对象关系映射（ORM）框架，它允许开发人员使用面向对象的模型来操作关系数据库。\n### SqlSugar - ORM框架\nSqlSugar 是一款老牌.NET 开源多库架构ORM框架（EF Core单库架构），由果糖大数据科技团队. 维护和更新。\n### SubSonic - ORM框架\n> SubSonic 是一个开源的.NET ORM框架，它允许开发人员使用面向对象的模型来操作关系数据库。\n# 第三方接口库\n### DotNetCore.SKIT.FlurlHttpClient.Wechat -  微信接口库\n> 微信开放平台API接口封装库，支持微信公众号、小程序、企业号、企业微信、微信支付、开放平台、企业内部系统对接。\n\n# WPF UI库\n### MaterialDesignThemes.Wpf\n### HandyControl \n### MahApps.Metro \n### Fluent.Ribbon - 像 Office 中一样的 WPF 功能区控件\n### WPF UI - WPF是用于构建桌面应用程序的.NET框架。\n# 扩展\n- **XAML Styler:** XAML 格式化（  (?<=\\r\\n)\\r\\n  ）\n- **ResXManager:** 使用基于 resx 的资源本地化和管理各种应用程序的最流行工具。显示解决方案的所有资源，让您在排列良好的数据网格中编辑字符串及其本地化。\n- **Codemaid:** 一个开源 Visual Studio 扩展，用于清理和简化 C#、C++、F#、VB、PHP、PowerShell、R、JSON、XAML、XML、ASP、HTML、CSS、LESS、SCSS、JavaScript 和 TypeScript 编码。\n\n\n","source":"_posts/10.其他/Net扩展与库.md","raw":"---\ntitle: .Net扩展、库、工具、持续更新\ndate: 2023-12-2 14:00:40\ncategories: 后端笔记\ntags: \n- C#\n- .Net Core\n---\n# 库与框架\n## .Net系统框架\n### Avalonia - 跨平台 UI 框架\n> Avalonia是 dotnet 的跨平台 UI 框架，提供灵活的样式系统，支持 Windows、macOS、Linux、iOS、Android 和 WebAssembly 等多种平台。\n\n### Ant Design of Blazor \n> Blazor样板的企业应用程序的开箱即用 UI 解决方案\n\n## 容器注入\n\n### Autofac\n> Autofac是一个用于依赖注入（DI）和反转控制（IoC）的.NET库，提供了一个容器，用于注册、解析和管理应用程序中的组件，这些组件包括服务、对象和其他依赖项。\n\n\n### Prism - 框架库\n> Prism 是一个框架，用于在 WPF 和 Xamarin Forms 中构建松散耦合、可维护和可测试的 XAML 应用程序。每个平台都有单独的版本，并且这些版本将按照独立的时间表进行开发。Prism 提供了一系列设计模式的实现，这些设计模式有助于编写结构良好且可维护的 XAML 应用程序，包括 MVVM、依赖项注入、命令、EventAggregator 等。\n\n\n### CommunityToolkit.MVVM - MVVM 工具包\n> CommunityToolkit.MVVM是一个用于创建基于MVVM（Model-View-ViewModel）设计模式的应用程序的开源工具包，它是Microsoft的CommunityToolkit项目的一部分。这个工具包旨在帮助开发人员更容易地构建XAML应用程序。\n\n## 图表\n### LiveChartsCore.SkiaSharpView.WPF - 实时图表\n> LiveCharts 是一个.Net 数据可视化库，可以跨多个设备和框架运行。包含MAUI，AVALONIA，UNO PLATFORM， ETOFOROMS，XAMARIN，BLAZOR WASM，WPF。\n### SparrowToolkit \n> 一套WPF图表控件集，支持绘制动态曲线，可绘制示波器、CPU使用率和波形。\n## 文档操作\n### iTextSharp\n> iTextSharp是一个用于生成和操作PDF文档的C#库。它允许开发人员创建、读取、修改和分析PDF\n### QuestPDF - 生成 PDF 文档的现代开源 .NET 库\n> QuestPDF 是一个用于生成 PDF 文档的现代开源 .NET 库。它支持所有 .NET 平台，包括 .NET Framework、.\n\n### HtmlAgilityPack - 爬虫库\n> HtmlAgilityPack是一个基于.Net的、第三方免费开源的微型类库,主要用于在服务器端解析html文档。\n\n### NPOI - 工具库\n> 一个用于操作Microsoft Office文件格式的开源库。它允许开发人员在.NET平台上创建、读取和编辑Microsoft Excel（.xls和.xlsx）、Word和PowerPoint等文件格式。NPOI 提供了一种方便的方式来处理Office文档，以便在应用程序中进行数据导入、导出、报表生成等操作。\n\n## 通讯\n### SignalR - 通讯库\n> SignalR 是一个开源的.NET库，用于在实时应用程序中实现双向通信。它允许开发人员构建具有实时功能的应用程序，例如聊天应用、在线游戏、协作工具、股票市场更新、监控系统等。\n\n## 任务调度框架\n### Quartz.Net - 任务调度框架\n> 用于构建作业调度应用程序的.NET库。它支持多种存储类型，包括关系数据库、文件、MSMQ、RavenDB、SQLServer、Oracle、MySQL、PostgreSQL、SQLite、NoSQL等。\n### Hangfire - 任务调度框架\n> Hangfire 是一个开源的.NET库，用于在后台执行任务调度。\n### Topshelf\n> Topshelf 是一个开源的.NET库，用于构建Windows服务。它提供了一个简单的API，用于定义、安装和运行.NETWindows服务。\n\n## 分布式缓存框架\n### StackExchange.Redis - 分布式缓存框架\n> 用于构建分布式缓存系统的.NET客户端库。它支持Redis、Memcached、Couchbase和MongoDB等缓存系统\n### Memcahed -  分布式缓存框架\n> Memcached 是一个高性能、分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。\n\n## 中间件与消息队列\n### RabbitMQ\n> 基于 AMQP 协议，RabbitMQ 是一个开源的，由 Erlang 语言编写的，面向消息的中间件。\n### Redis \n> Redis 是一个开源的、内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。\n### Kafka/Jafka\n> Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布/订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。\n## 常用ORM框架\n### Dapper - 轻量级ORM框架\n> Dapper 是一个轻量级的ORM框架，它允许开发人员通过简单、一致和类型安全的API来访问数据库。\n### NHibernate - ORM框架\n> NHibernate 是一个开源的对象关系映射（ORM）框架，它允许开发人员使用面向对象的模型来操作关系数据库。\n### EntityFramework - ORM框架\n> 微软的Entity Framework 是一个对象关系映射（ORM）框架，它允许开发人员使用面向对象的模型来操作关系数据库。\n### SqlSugar - ORM框架\nSqlSugar 是一款老牌.NET 开源多库架构ORM框架（EF Core单库架构），由果糖大数据科技团队. 维护和更新。\n### SubSonic - ORM框架\n> SubSonic 是一个开源的.NET ORM框架，它允许开发人员使用面向对象的模型来操作关系数据库。\n# 第三方接口库\n### DotNetCore.SKIT.FlurlHttpClient.Wechat -  微信接口库\n> 微信开放平台API接口封装库，支持微信公众号、小程序、企业号、企业微信、微信支付、开放平台、企业内部系统对接。\n\n# WPF UI库\n### MaterialDesignThemes.Wpf\n### HandyControl \n### MahApps.Metro \n### Fluent.Ribbon - 像 Office 中一样的 WPF 功能区控件\n### WPF UI - WPF是用于构建桌面应用程序的.NET框架。\n# 扩展\n- **XAML Styler:** XAML 格式化（  (?<=\\r\\n)\\r\\n  ）\n- **ResXManager:** 使用基于 resx 的资源本地化和管理各种应用程序的最流行工具。显示解决方案的所有资源，让您在排列良好的数据网格中编辑字符串及其本地化。\n- **Codemaid:** 一个开源 Visual Studio 扩展，用于清理和简化 C#、C++、F#、VB、PHP、PowerShell、R、JSON、XAML、XML、ASP、HTML、CSS、LESS、SCSS、JavaScript 和 TypeScript 编码。\n\n\n","slug":"10.其他/Net扩展与库","published":1,"updated":"2023-12-02T07:21:14.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqv000wjkgl6sq2fpwk","content":"<h1 id=\"库与框架\"><a href=\"#库与框架\" class=\"headerlink\" title=\"库与框架\"></a>库与框架</h1><h2 id=\"Net系统框架\"><a href=\"#Net系统框架\" class=\"headerlink\" title=\".Net系统框架\"></a>.Net系统框架</h2><h3 id=\"Avalonia-跨平台-UI-框架\"><a href=\"#Avalonia-跨平台-UI-框架\" class=\"headerlink\" title=\"Avalonia - 跨平台 UI 框架\"></a>Avalonia - 跨平台 UI 框架</h3><blockquote>\n<p>Avalonia是 dotnet 的跨平台 UI 框架，提供灵活的样式系统，支持 Windows、macOS、Linux、iOS、Android 和 WebAssembly 等多种平台。</p>\n</blockquote>\n<h3 id=\"Ant-Design-of-Blazor\"><a href=\"#Ant-Design-of-Blazor\" class=\"headerlink\" title=\"Ant Design of Blazor\"></a>Ant Design of Blazor</h3><blockquote>\n<p>Blazor样板的企业应用程序的开箱即用 UI 解决方案</p>\n</blockquote>\n<h2 id=\"容器注入\"><a href=\"#容器注入\" class=\"headerlink\" title=\"容器注入\"></a>容器注入</h2><h3 id=\"Autofac\"><a href=\"#Autofac\" class=\"headerlink\" title=\"Autofac\"></a>Autofac</h3><blockquote>\n<p>Autofac是一个用于依赖注入（DI）和反转控制（IoC）的.NET库，提供了一个容器，用于注册、解析和管理应用程序中的组件，这些组件包括服务、对象和其他依赖项。</p>\n</blockquote>\n<h3 id=\"Prism-框架库\"><a href=\"#Prism-框架库\" class=\"headerlink\" title=\"Prism - 框架库\"></a>Prism - 框架库</h3><blockquote>\n<p>Prism 是一个框架，用于在 WPF 和 Xamarin Forms 中构建松散耦合、可维护和可测试的 XAML 应用程序。每个平台都有单独的版本，并且这些版本将按照独立的时间表进行开发。Prism 提供了一系列设计模式的实现，这些设计模式有助于编写结构良好且可维护的 XAML 应用程序，包括 MVVM、依赖项注入、命令、EventAggregator 等。</p>\n</blockquote>\n<h3 id=\"CommunityToolkit-MVVM-MVVM-工具包\"><a href=\"#CommunityToolkit-MVVM-MVVM-工具包\" class=\"headerlink\" title=\"CommunityToolkit.MVVM - MVVM 工具包\"></a>CommunityToolkit.MVVM - MVVM 工具包</h3><blockquote>\n<p>CommunityToolkit.MVVM是一个用于创建基于MVVM（Model-View-ViewModel）设计模式的应用程序的开源工具包，它是Microsoft的CommunityToolkit项目的一部分。这个工具包旨在帮助开发人员更容易地构建XAML应用程序。</p>\n</blockquote>\n<h2 id=\"图表\"><a href=\"#图表\" class=\"headerlink\" title=\"图表\"></a>图表</h2><h3 id=\"LiveChartsCore-SkiaSharpView-WPF-实时图表\"><a href=\"#LiveChartsCore-SkiaSharpView-WPF-实时图表\" class=\"headerlink\" title=\"LiveChartsCore.SkiaSharpView.WPF - 实时图表\"></a>LiveChartsCore.SkiaSharpView.WPF - 实时图表</h3><blockquote>\n<p>LiveCharts 是一个.Net 数据可视化库，可以跨多个设备和框架运行。包含MAUI，AVALONIA，UNO PLATFORM， ETOFOROMS，XAMARIN，BLAZOR WASM，WPF。</p>\n</blockquote>\n<h3 id=\"SparrowToolkit\"><a href=\"#SparrowToolkit\" class=\"headerlink\" title=\"SparrowToolkit\"></a>SparrowToolkit</h3><blockquote>\n<p>一套WPF图表控件集，支持绘制动态曲线，可绘制示波器、CPU使用率和波形。</p>\n</blockquote>\n<h2 id=\"文档操作\"><a href=\"#文档操作\" class=\"headerlink\" title=\"文档操作\"></a>文档操作</h2><h3 id=\"iTextSharp\"><a href=\"#iTextSharp\" class=\"headerlink\" title=\"iTextSharp\"></a>iTextSharp</h3><blockquote>\n<p>iTextSharp是一个用于生成和操作PDF文档的C#库。它允许开发人员创建、读取、修改和分析PDF</p>\n</blockquote>\n<h3 id=\"QuestPDF-生成-PDF-文档的现代开源-NET-库\"><a href=\"#QuestPDF-生成-PDF-文档的现代开源-NET-库\" class=\"headerlink\" title=\"QuestPDF - 生成 PDF 文档的现代开源 .NET 库\"></a>QuestPDF - 生成 PDF 文档的现代开源 .NET 库</h3><blockquote>\n<p>QuestPDF 是一个用于生成 PDF 文档的现代开源 .NET 库。它支持所有 .NET 平台，包括 .NET Framework、.</p>\n</blockquote>\n<h3 id=\"HtmlAgilityPack-爬虫库\"><a href=\"#HtmlAgilityPack-爬虫库\" class=\"headerlink\" title=\"HtmlAgilityPack - 爬虫库\"></a>HtmlAgilityPack - 爬虫库</h3><blockquote>\n<p>HtmlAgilityPack是一个基于.Net的、第三方免费开源的微型类库,主要用于在服务器端解析html文档。</p>\n</blockquote>\n<h3 id=\"NPOI-工具库\"><a href=\"#NPOI-工具库\" class=\"headerlink\" title=\"NPOI - 工具库\"></a>NPOI - 工具库</h3><blockquote>\n<p>一个用于操作Microsoft Office文件格式的开源库。它允许开发人员在.NET平台上创建、读取和编辑Microsoft Excel（.xls和.xlsx）、Word和PowerPoint等文件格式。NPOI 提供了一种方便的方式来处理Office文档，以便在应用程序中进行数据导入、导出、报表生成等操作。</p>\n</blockquote>\n<h2 id=\"通讯\"><a href=\"#通讯\" class=\"headerlink\" title=\"通讯\"></a>通讯</h2><h3 id=\"SignalR-通讯库\"><a href=\"#SignalR-通讯库\" class=\"headerlink\" title=\"SignalR - 通讯库\"></a>SignalR - 通讯库</h3><blockquote>\n<p>SignalR 是一个开源的.NET库，用于在实时应用程序中实现双向通信。它允许开发人员构建具有实时功能的应用程序，例如聊天应用、在线游戏、协作工具、股票市场更新、监控系统等。</p>\n</blockquote>\n<h2 id=\"任务调度框架\"><a href=\"#任务调度框架\" class=\"headerlink\" title=\"任务调度框架\"></a>任务调度框架</h2><h3 id=\"Quartz-Net-任务调度框架\"><a href=\"#Quartz-Net-任务调度框架\" class=\"headerlink\" title=\"Quartz.Net - 任务调度框架\"></a>Quartz.Net - 任务调度框架</h3><blockquote>\n<p>用于构建作业调度应用程序的.NET库。它支持多种存储类型，包括关系数据库、文件、MSMQ、RavenDB、SQLServer、Oracle、MySQL、PostgreSQL、SQLite、NoSQL等。</p>\n</blockquote>\n<h3 id=\"Hangfire-任务调度框架\"><a href=\"#Hangfire-任务调度框架\" class=\"headerlink\" title=\"Hangfire - 任务调度框架\"></a>Hangfire - 任务调度框架</h3><blockquote>\n<p>Hangfire 是一个开源的.NET库，用于在后台执行任务调度。</p>\n</blockquote>\n<h3 id=\"Topshelf\"><a href=\"#Topshelf\" class=\"headerlink\" title=\"Topshelf\"></a>Topshelf</h3><blockquote>\n<p>Topshelf 是一个开源的.NET库，用于构建Windows服务。它提供了一个简单的API，用于定义、安装和运行.NETWindows服务。</p>\n</blockquote>\n<h2 id=\"分布式缓存框架\"><a href=\"#分布式缓存框架\" class=\"headerlink\" title=\"分布式缓存框架\"></a>分布式缓存框架</h2><h3 id=\"StackExchange-Redis-分布式缓存框架\"><a href=\"#StackExchange-Redis-分布式缓存框架\" class=\"headerlink\" title=\"StackExchange.Redis - 分布式缓存框架\"></a>StackExchange.Redis - 分布式缓存框架</h3><blockquote>\n<p>用于构建分布式缓存系统的.NET客户端库。它支持Redis、Memcached、Couchbase和MongoDB等缓存系统</p>\n</blockquote>\n<h3 id=\"Memcahed-分布式缓存框架\"><a href=\"#Memcahed-分布式缓存框架\" class=\"headerlink\" title=\"Memcahed -  分布式缓存框架\"></a>Memcahed -  分布式缓存框架</h3><blockquote>\n<p>Memcached 是一个高性能、分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。</p>\n</blockquote>\n<h2 id=\"中间件与消息队列\"><a href=\"#中间件与消息队列\" class=\"headerlink\" title=\"中间件与消息队列\"></a>中间件与消息队列</h2><h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><blockquote>\n<p>基于 AMQP 协议，RabbitMQ 是一个开源的，由 Erlang 语言编写的，面向消息的中间件。</p>\n</blockquote>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><blockquote>\n<p>Redis 是一个开源的、内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</p>\n</blockquote>\n<h3 id=\"Kafka-Jafka\"><a href=\"#Kafka-Jafka\" class=\"headerlink\" title=\"Kafka&#x2F;Jafka\"></a>Kafka&#x2F;Jafka</h3><blockquote>\n<p>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布&#x2F;订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。</p>\n</blockquote>\n<h2 id=\"常用ORM框架\"><a href=\"#常用ORM框架\" class=\"headerlink\" title=\"常用ORM框架\"></a>常用ORM框架</h2><h3 id=\"Dapper-轻量级ORM框架\"><a href=\"#Dapper-轻量级ORM框架\" class=\"headerlink\" title=\"Dapper - 轻量级ORM框架\"></a>Dapper - 轻量级ORM框架</h3><blockquote>\n<p>Dapper 是一个轻量级的ORM框架，它允许开发人员通过简单、一致和类型安全的API来访问数据库。</p>\n</blockquote>\n<h3 id=\"NHibernate-ORM框架\"><a href=\"#NHibernate-ORM框架\" class=\"headerlink\" title=\"NHibernate - ORM框架\"></a>NHibernate - ORM框架</h3><blockquote>\n<p>NHibernate 是一个开源的对象关系映射（ORM）框架，它允许开发人员使用面向对象的模型来操作关系数据库。</p>\n</blockquote>\n<h3 id=\"EntityFramework-ORM框架\"><a href=\"#EntityFramework-ORM框架\" class=\"headerlink\" title=\"EntityFramework - ORM框架\"></a>EntityFramework - ORM框架</h3><blockquote>\n<p>微软的Entity Framework 是一个对象关系映射（ORM）框架，它允许开发人员使用面向对象的模型来操作关系数据库。</p>\n</blockquote>\n<h3 id=\"SqlSugar-ORM框架\"><a href=\"#SqlSugar-ORM框架\" class=\"headerlink\" title=\"SqlSugar - ORM框架\"></a>SqlSugar - ORM框架</h3><p>SqlSugar 是一款老牌.NET 开源多库架构ORM框架（EF Core单库架构），由果糖大数据科技团队. 维护和更新。</p>\n<h3 id=\"SubSonic-ORM框架\"><a href=\"#SubSonic-ORM框架\" class=\"headerlink\" title=\"SubSonic - ORM框架\"></a>SubSonic - ORM框架</h3><blockquote>\n<p>SubSonic 是一个开源的.NET ORM框架，它允许开发人员使用面向对象的模型来操作关系数据库。</p>\n</blockquote>\n<h1 id=\"第三方接口库\"><a href=\"#第三方接口库\" class=\"headerlink\" title=\"第三方接口库\"></a>第三方接口库</h1><h3 id=\"DotNetCore-SKIT-FlurlHttpClient-Wechat-微信接口库\"><a href=\"#DotNetCore-SKIT-FlurlHttpClient-Wechat-微信接口库\" class=\"headerlink\" title=\"DotNetCore.SKIT.FlurlHttpClient.Wechat -  微信接口库\"></a>DotNetCore.SKIT.FlurlHttpClient.Wechat -  微信接口库</h3><blockquote>\n<p>微信开放平台API接口封装库，支持微信公众号、小程序、企业号、企业微信、微信支付、开放平台、企业内部系统对接。</p>\n</blockquote>\n<h1 id=\"WPF-UI库\"><a href=\"#WPF-UI库\" class=\"headerlink\" title=\"WPF UI库\"></a>WPF UI库</h1><h3 id=\"MaterialDesignThemes-Wpf\"><a href=\"#MaterialDesignThemes-Wpf\" class=\"headerlink\" title=\"MaterialDesignThemes.Wpf\"></a>MaterialDesignThemes.Wpf</h3><h3 id=\"HandyControl\"><a href=\"#HandyControl\" class=\"headerlink\" title=\"HandyControl\"></a>HandyControl</h3><h3 id=\"MahApps-Metro\"><a href=\"#MahApps-Metro\" class=\"headerlink\" title=\"MahApps.Metro\"></a>MahApps.Metro</h3><h3 id=\"Fluent-Ribbon-像-Office-中一样的-WPF-功能区控件\"><a href=\"#Fluent-Ribbon-像-Office-中一样的-WPF-功能区控件\" class=\"headerlink\" title=\"Fluent.Ribbon - 像 Office 中一样的 WPF 功能区控件\"></a>Fluent.Ribbon - 像 Office 中一样的 WPF 功能区控件</h3><h3 id=\"WPF-UI-WPF是用于构建桌面应用程序的-NET框架。\"><a href=\"#WPF-UI-WPF是用于构建桌面应用程序的-NET框架。\" class=\"headerlink\" title=\"WPF UI - WPF是用于构建桌面应用程序的.NET框架。\"></a>WPF UI - WPF是用于构建桌面应用程序的.NET框架。</h3><h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><ul>\n<li><strong>XAML Styler:</strong> XAML 格式化（  (?&lt;&#x3D;\\r\\n)\\r\\n  ）</li>\n<li><strong>ResXManager:</strong> 使用基于 resx 的资源本地化和管理各种应用程序的最流行工具。显示解决方案的所有资源，让您在排列良好的数据网格中编辑字符串及其本地化。</li>\n<li><strong>Codemaid:</strong> 一个开源 Visual Studio 扩展，用于清理和简化 C#、C++、F#、VB、PHP、PowerShell、R、JSON、XAML、XML、ASP、HTML、CSS、LESS、SCSS、JavaScript 和 TypeScript 编码。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"库与框架\"><a href=\"#库与框架\" class=\"headerlink\" title=\"库与框架\"></a>库与框架</h1><h2 id=\"Net系统框架\"><a href=\"#Net系统框架\" class=\"headerlink\" title=\".Net系统框架\"></a>.Net系统框架</h2><h3 id=\"Avalonia-跨平台-UI-框架\"><a href=\"#Avalonia-跨平台-UI-框架\" class=\"headerlink\" title=\"Avalonia - 跨平台 UI 框架\"></a>Avalonia - 跨平台 UI 框架</h3><blockquote>\n<p>Avalonia是 dotnet 的跨平台 UI 框架，提供灵活的样式系统，支持 Windows、macOS、Linux、iOS、Android 和 WebAssembly 等多种平台。</p>\n</blockquote>\n<h3 id=\"Ant-Design-of-Blazor\"><a href=\"#Ant-Design-of-Blazor\" class=\"headerlink\" title=\"Ant Design of Blazor\"></a>Ant Design of Blazor</h3><blockquote>\n<p>Blazor样板的企业应用程序的开箱即用 UI 解决方案</p>\n</blockquote>\n<h2 id=\"容器注入\"><a href=\"#容器注入\" class=\"headerlink\" title=\"容器注入\"></a>容器注入</h2><h3 id=\"Autofac\"><a href=\"#Autofac\" class=\"headerlink\" title=\"Autofac\"></a>Autofac</h3><blockquote>\n<p>Autofac是一个用于依赖注入（DI）和反转控制（IoC）的.NET库，提供了一个容器，用于注册、解析和管理应用程序中的组件，这些组件包括服务、对象和其他依赖项。</p>\n</blockquote>\n<h3 id=\"Prism-框架库\"><a href=\"#Prism-框架库\" class=\"headerlink\" title=\"Prism - 框架库\"></a>Prism - 框架库</h3><blockquote>\n<p>Prism 是一个框架，用于在 WPF 和 Xamarin Forms 中构建松散耦合、可维护和可测试的 XAML 应用程序。每个平台都有单独的版本，并且这些版本将按照独立的时间表进行开发。Prism 提供了一系列设计模式的实现，这些设计模式有助于编写结构良好且可维护的 XAML 应用程序，包括 MVVM、依赖项注入、命令、EventAggregator 等。</p>\n</blockquote>\n<h3 id=\"CommunityToolkit-MVVM-MVVM-工具包\"><a href=\"#CommunityToolkit-MVVM-MVVM-工具包\" class=\"headerlink\" title=\"CommunityToolkit.MVVM - MVVM 工具包\"></a>CommunityToolkit.MVVM - MVVM 工具包</h3><blockquote>\n<p>CommunityToolkit.MVVM是一个用于创建基于MVVM（Model-View-ViewModel）设计模式的应用程序的开源工具包，它是Microsoft的CommunityToolkit项目的一部分。这个工具包旨在帮助开发人员更容易地构建XAML应用程序。</p>\n</blockquote>\n<h2 id=\"图表\"><a href=\"#图表\" class=\"headerlink\" title=\"图表\"></a>图表</h2><h3 id=\"LiveChartsCore-SkiaSharpView-WPF-实时图表\"><a href=\"#LiveChartsCore-SkiaSharpView-WPF-实时图表\" class=\"headerlink\" title=\"LiveChartsCore.SkiaSharpView.WPF - 实时图表\"></a>LiveChartsCore.SkiaSharpView.WPF - 实时图表</h3><blockquote>\n<p>LiveCharts 是一个.Net 数据可视化库，可以跨多个设备和框架运行。包含MAUI，AVALONIA，UNO PLATFORM， ETOFOROMS，XAMARIN，BLAZOR WASM，WPF。</p>\n</blockquote>\n<h3 id=\"SparrowToolkit\"><a href=\"#SparrowToolkit\" class=\"headerlink\" title=\"SparrowToolkit\"></a>SparrowToolkit</h3><blockquote>\n<p>一套WPF图表控件集，支持绘制动态曲线，可绘制示波器、CPU使用率和波形。</p>\n</blockquote>\n<h2 id=\"文档操作\"><a href=\"#文档操作\" class=\"headerlink\" title=\"文档操作\"></a>文档操作</h2><h3 id=\"iTextSharp\"><a href=\"#iTextSharp\" class=\"headerlink\" title=\"iTextSharp\"></a>iTextSharp</h3><blockquote>\n<p>iTextSharp是一个用于生成和操作PDF文档的C#库。它允许开发人员创建、读取、修改和分析PDF</p>\n</blockquote>\n<h3 id=\"QuestPDF-生成-PDF-文档的现代开源-NET-库\"><a href=\"#QuestPDF-生成-PDF-文档的现代开源-NET-库\" class=\"headerlink\" title=\"QuestPDF - 生成 PDF 文档的现代开源 .NET 库\"></a>QuestPDF - 生成 PDF 文档的现代开源 .NET 库</h3><blockquote>\n<p>QuestPDF 是一个用于生成 PDF 文档的现代开源 .NET 库。它支持所有 .NET 平台，包括 .NET Framework、.</p>\n</blockquote>\n<h3 id=\"HtmlAgilityPack-爬虫库\"><a href=\"#HtmlAgilityPack-爬虫库\" class=\"headerlink\" title=\"HtmlAgilityPack - 爬虫库\"></a>HtmlAgilityPack - 爬虫库</h3><blockquote>\n<p>HtmlAgilityPack是一个基于.Net的、第三方免费开源的微型类库,主要用于在服务器端解析html文档。</p>\n</blockquote>\n<h3 id=\"NPOI-工具库\"><a href=\"#NPOI-工具库\" class=\"headerlink\" title=\"NPOI - 工具库\"></a>NPOI - 工具库</h3><blockquote>\n<p>一个用于操作Microsoft Office文件格式的开源库。它允许开发人员在.NET平台上创建、读取和编辑Microsoft Excel（.xls和.xlsx）、Word和PowerPoint等文件格式。NPOI 提供了一种方便的方式来处理Office文档，以便在应用程序中进行数据导入、导出、报表生成等操作。</p>\n</blockquote>\n<h2 id=\"通讯\"><a href=\"#通讯\" class=\"headerlink\" title=\"通讯\"></a>通讯</h2><h3 id=\"SignalR-通讯库\"><a href=\"#SignalR-通讯库\" class=\"headerlink\" title=\"SignalR - 通讯库\"></a>SignalR - 通讯库</h3><blockquote>\n<p>SignalR 是一个开源的.NET库，用于在实时应用程序中实现双向通信。它允许开发人员构建具有实时功能的应用程序，例如聊天应用、在线游戏、协作工具、股票市场更新、监控系统等。</p>\n</blockquote>\n<h2 id=\"任务调度框架\"><a href=\"#任务调度框架\" class=\"headerlink\" title=\"任务调度框架\"></a>任务调度框架</h2><h3 id=\"Quartz-Net-任务调度框架\"><a href=\"#Quartz-Net-任务调度框架\" class=\"headerlink\" title=\"Quartz.Net - 任务调度框架\"></a>Quartz.Net - 任务调度框架</h3><blockquote>\n<p>用于构建作业调度应用程序的.NET库。它支持多种存储类型，包括关系数据库、文件、MSMQ、RavenDB、SQLServer、Oracle、MySQL、PostgreSQL、SQLite、NoSQL等。</p>\n</blockquote>\n<h3 id=\"Hangfire-任务调度框架\"><a href=\"#Hangfire-任务调度框架\" class=\"headerlink\" title=\"Hangfire - 任务调度框架\"></a>Hangfire - 任务调度框架</h3><blockquote>\n<p>Hangfire 是一个开源的.NET库，用于在后台执行任务调度。</p>\n</blockquote>\n<h3 id=\"Topshelf\"><a href=\"#Topshelf\" class=\"headerlink\" title=\"Topshelf\"></a>Topshelf</h3><blockquote>\n<p>Topshelf 是一个开源的.NET库，用于构建Windows服务。它提供了一个简单的API，用于定义、安装和运行.NETWindows服务。</p>\n</blockquote>\n<h2 id=\"分布式缓存框架\"><a href=\"#分布式缓存框架\" class=\"headerlink\" title=\"分布式缓存框架\"></a>分布式缓存框架</h2><h3 id=\"StackExchange-Redis-分布式缓存框架\"><a href=\"#StackExchange-Redis-分布式缓存框架\" class=\"headerlink\" title=\"StackExchange.Redis - 分布式缓存框架\"></a>StackExchange.Redis - 分布式缓存框架</h3><blockquote>\n<p>用于构建分布式缓存系统的.NET客户端库。它支持Redis、Memcached、Couchbase和MongoDB等缓存系统</p>\n</blockquote>\n<h3 id=\"Memcahed-分布式缓存框架\"><a href=\"#Memcahed-分布式缓存框架\" class=\"headerlink\" title=\"Memcahed -  分布式缓存框架\"></a>Memcahed -  分布式缓存框架</h3><blockquote>\n<p>Memcached 是一个高性能、分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。</p>\n</blockquote>\n<h2 id=\"中间件与消息队列\"><a href=\"#中间件与消息队列\" class=\"headerlink\" title=\"中间件与消息队列\"></a>中间件与消息队列</h2><h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><blockquote>\n<p>基于 AMQP 协议，RabbitMQ 是一个开源的，由 Erlang 语言编写的，面向消息的中间件。</p>\n</blockquote>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><blockquote>\n<p>Redis 是一个开源的、内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。</p>\n</blockquote>\n<h3 id=\"Kafka-Jafka\"><a href=\"#Kafka-Jafka\" class=\"headerlink\" title=\"Kafka&#x2F;Jafka\"></a>Kafka&#x2F;Jafka</h3><blockquote>\n<p>Kafka是Apache下的一个子项目，是一个高性能跨语言分布式发布&#x2F;订阅消息队列系统，而Jafka是在Kafka之上孵化而来的，即Kafka的一个升级版。</p>\n</blockquote>\n<h2 id=\"常用ORM框架\"><a href=\"#常用ORM框架\" class=\"headerlink\" title=\"常用ORM框架\"></a>常用ORM框架</h2><h3 id=\"Dapper-轻量级ORM框架\"><a href=\"#Dapper-轻量级ORM框架\" class=\"headerlink\" title=\"Dapper - 轻量级ORM框架\"></a>Dapper - 轻量级ORM框架</h3><blockquote>\n<p>Dapper 是一个轻量级的ORM框架，它允许开发人员通过简单、一致和类型安全的API来访问数据库。</p>\n</blockquote>\n<h3 id=\"NHibernate-ORM框架\"><a href=\"#NHibernate-ORM框架\" class=\"headerlink\" title=\"NHibernate - ORM框架\"></a>NHibernate - ORM框架</h3><blockquote>\n<p>NHibernate 是一个开源的对象关系映射（ORM）框架，它允许开发人员使用面向对象的模型来操作关系数据库。</p>\n</blockquote>\n<h3 id=\"EntityFramework-ORM框架\"><a href=\"#EntityFramework-ORM框架\" class=\"headerlink\" title=\"EntityFramework - ORM框架\"></a>EntityFramework - ORM框架</h3><blockquote>\n<p>微软的Entity Framework 是一个对象关系映射（ORM）框架，它允许开发人员使用面向对象的模型来操作关系数据库。</p>\n</blockquote>\n<h3 id=\"SqlSugar-ORM框架\"><a href=\"#SqlSugar-ORM框架\" class=\"headerlink\" title=\"SqlSugar - ORM框架\"></a>SqlSugar - ORM框架</h3><p>SqlSugar 是一款老牌.NET 开源多库架构ORM框架（EF Core单库架构），由果糖大数据科技团队. 维护和更新。</p>\n<h3 id=\"SubSonic-ORM框架\"><a href=\"#SubSonic-ORM框架\" class=\"headerlink\" title=\"SubSonic - ORM框架\"></a>SubSonic - ORM框架</h3><blockquote>\n<p>SubSonic 是一个开源的.NET ORM框架，它允许开发人员使用面向对象的模型来操作关系数据库。</p>\n</blockquote>\n<h1 id=\"第三方接口库\"><a href=\"#第三方接口库\" class=\"headerlink\" title=\"第三方接口库\"></a>第三方接口库</h1><h3 id=\"DotNetCore-SKIT-FlurlHttpClient-Wechat-微信接口库\"><a href=\"#DotNetCore-SKIT-FlurlHttpClient-Wechat-微信接口库\" class=\"headerlink\" title=\"DotNetCore.SKIT.FlurlHttpClient.Wechat -  微信接口库\"></a>DotNetCore.SKIT.FlurlHttpClient.Wechat -  微信接口库</h3><blockquote>\n<p>微信开放平台API接口封装库，支持微信公众号、小程序、企业号、企业微信、微信支付、开放平台、企业内部系统对接。</p>\n</blockquote>\n<h1 id=\"WPF-UI库\"><a href=\"#WPF-UI库\" class=\"headerlink\" title=\"WPF UI库\"></a>WPF UI库</h1><h3 id=\"MaterialDesignThemes-Wpf\"><a href=\"#MaterialDesignThemes-Wpf\" class=\"headerlink\" title=\"MaterialDesignThemes.Wpf\"></a>MaterialDesignThemes.Wpf</h3><h3 id=\"HandyControl\"><a href=\"#HandyControl\" class=\"headerlink\" title=\"HandyControl\"></a>HandyControl</h3><h3 id=\"MahApps-Metro\"><a href=\"#MahApps-Metro\" class=\"headerlink\" title=\"MahApps.Metro\"></a>MahApps.Metro</h3><h3 id=\"Fluent-Ribbon-像-Office-中一样的-WPF-功能区控件\"><a href=\"#Fluent-Ribbon-像-Office-中一样的-WPF-功能区控件\" class=\"headerlink\" title=\"Fluent.Ribbon - 像 Office 中一样的 WPF 功能区控件\"></a>Fluent.Ribbon - 像 Office 中一样的 WPF 功能区控件</h3><h3 id=\"WPF-UI-WPF是用于构建桌面应用程序的-NET框架。\"><a href=\"#WPF-UI-WPF是用于构建桌面应用程序的-NET框架。\" class=\"headerlink\" title=\"WPF UI - WPF是用于构建桌面应用程序的.NET框架。\"></a>WPF UI - WPF是用于构建桌面应用程序的.NET框架。</h3><h1 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h1><ul>\n<li><strong>XAML Styler:</strong> XAML 格式化（  (?&lt;&#x3D;\\r\\n)\\r\\n  ）</li>\n<li><strong>ResXManager:</strong> 使用基于 resx 的资源本地化和管理各种应用程序的最流行工具。显示解决方案的所有资源，让您在排列良好的数据网格中编辑字符串及其本地化。</li>\n<li><strong>Codemaid:</strong> 一个开源 Visual Studio 扩展，用于清理和简化 C#、C++、F#、VB、PHP、PowerShell、R、JSON、XAML、XML、ASP、HTML、CSS、LESS、SCSS、JavaScript 和 TypeScript 编码。</li>\n</ul>\n"},{"title":"SOLID原则","date":"2019-10-20T01:00:36.000Z","_content":"# SOLID原则\n## 什么是SOLID\n\n首先SOLOD原则就是一组面向对象编程的设计原则，主要作用是改善软件设计、提高代码质量，增加软件的可维护性和可扩展性。\n\nSOLID相应代表：\n- **S 单一职责原则(Single Responsibility Principle)**\n- **O 开放封闭原则(Open/Closed Principle)**\n- **L 里氏替换原则(Liskov Substiution Principle)**\n- **O 接口隔离原则(Interface Segregation Principle)**\n- **D 依赖反转原则(Dependencey Inversion Principle)**\n\n## 单一职责原则\n单一职责原则主要介绍一个类的责任应该是单一的，它应该只有一个理由去来改变，类里的方法或属性应该与责任有关。每个类都有清晰的目标和职责。\n\n>简单来说让一个程序员去打代码，还要让设计海报，工作变得复杂，容易出错。那么我们要根据单一职责，以确保每项任务得到专业的处理，打代码的就是来代码，设计海报的就来设计海报。\n也可以理解为游戏中的法师、战士、辅助。他们都有特定的任务职责。\n\n### 违反单一职责的示例\n\n{% codeblock lang:C# %}\n/// <summary>\n/// 文件处理类\n/// </summary>\npublic class FileProcessor\n{\n    public string ReadFile(string filePath)\n    {\n        // 读取文件的具体实现\n    }\n\n    public int CountCharacters(string text)\n    {\n        // 统计字符数的具体实现\n    }\n}\n\n{% endcodeblock %}\n\n### 遵循单一职责的示例\n\n\n{% codeblock lang:C# %}\n \npublic class FileReader\n{\n    public string ReadFile(string filePath)\n    {\n        // 读取文件的具体实现\n    }\n}\n\npublic class CharacterCounter\n{\n    public int CountCharacters(string text)\n    {\n        // 统计字符数的具体实现\n    }\n}\n\n{% endcodeblock %}\n## 开放封闭原则\n开放封闭原则主要强调软件实体、类、模块、函数应该对扩展开放，对修改封闭。这意味着添加新的功能或者更改现有功能时，不应该修改已经存在的代码，而是应该通关扩展现有代码来实现。\n\n> 一旦写好一段代码，就不要再去修改他，相反如果添加新的功能，不要动原来的代码，而是在基础之上添加新的东西。如果在修改原来的代码可能会导致原来的功能变的不稳定。通过新的东西，可以确保旧的功能保持不变。\n\n### 违反开放封闭原则的示例\n\n一个图形绘制应用程序，后面添加新需求要求添加一个新的形状。\n{% codeblock lang:C# %}\npublic class Rectangle\n{\n    public double Width { get; set; }\n    public double Height { get; set; }\n}\n\npublic class AreaCalculator\n{\n    public double CalculateArea(object shape)\n    {\n        if (shape is Rectangle)\n        {\n            var rectangle = (Rectangle)shape;\n            return rectangle.Width * rectangle.Height;\n        }\n        // 现在需要添加一个新的形状（例如圆形）的计算，就需要修改这个类。\n        // 这违反了开放封闭原则。\n        else if (shape is Circle)\n        {\n            var circle = (Circle)shape;\n            return Math.PI * Math.Pow(circle.Radius, 2);\n        }\n        return 0;\n    }\n}\n\n{% endcodeblock %}\n\n### 遵循开放封闭原则的示例\n以下代码我们抽象类一个Shape类，定义了一个抽象方法，并有两个子类，每个类负责实现自己的计算面积方法。\n\n{% codeblock lang:C# %}\npublic abstroct class Shape\n{\n  public abstract double CalculateArea();\n\n}\n\npublic class Rectangle : Shape\n{\n    public double Width { get; set; }\n    public double Height { get; set; }\n\n    public override double CalculateArea()\n    {\n        return Width * Height;\n    }\n}\n\npublic class Circle : Shape\n{\n    public double Radius { get; set; }\n\n    public override double CalculateArea()\n    {\n        return Math.PI * Math.Pow(Radius, 2);\n    }\n}\n{% endcodeblock %}\n## 里氏替换原则\n里氏替换原则强调在面向对象中，子类应该能够替换其基类而不引起不一致或错误。如果一个类型是基类，那么它的子类应该可以无缝地替代它。\n- 子类必须保持基类的行为\n- 子类可以扩展基类的功能\n- 子类不应该引入新的错误\n- 子类不应该强制基类行为\n### 违背里氏替换原则的示例：\n假设我们有一个基类 Bird 表示鸟类，它有一个 Fly 方法用于飞翔。\n{% codeblock lang:C# %}\npublic class Bird\n{\n    public void Fly()\n    {\n        Console.WriteLine(\"这只鸟在飞翔\");\n    }\n}\n\n{% endcodeblock %}\n然后，我们创建了一个子类 Penguin 表示企鹅。企鹅是一种鸟，但它不会飞翔。\n{% codeblock lang:C# %}\npublic class Penguin : Bird\n{\n    // 企鹅不能飞，但我们仍然继承了父类的 Fly 方法，这违背了里氏替换原则。\n}\n{% endcodeblock %}\n\n### 遵守里氏替换原则的示例：\n为了遵守里氏替换原则，我们创建一个接口 IFlyable 表示可以飞翔的行为，然后只有能够飞翔的鸟类实现这个接口。\n\n{% codeblock lang:C# %}\npublic interface IFlyable\n{\n    void Fly();\n}\n\npublic class Bird : IFlyable\n{\n    public void Fly()\n    {\n        Console.WriteLine(\"这只鸟在飞翔\");\n    }\n}\n\npublic class Eagle : IFlyable\n{\n    public void Fly()\n    {\n        Console.WriteLine(\"这只鹰在飞翔\");\n    }\n}\n{% endcodeblock %}\n\n## 接口分离原则 \n接口分离原则强调一个类不应该强制实现它用不到的接口。\n- 接口应该小，不应该包含过多的方法\n- 类应该只实现与关系密切的接口，避免实现不相关方法\n- 如果一个接口变得很庞大，应该拆分成小接口\n### 违背接口分离的示例\n{% codeblock lang:C# %}\n\npublic interface IMultiFunctionDevice\n{\n    void Print();\n    void Scan();\n    void Copy();\n}\n//打印机不需要扫描和复印\npublic class AllInOnePrinter : IMultiFunctionDevice\n{\n    public void Print()\n    {\n        // 打印操作\n    }\n\n    public void Scan()\n    {\n        // 不需要扫描，但还是要实现\n    }\n\n    public void Copy()\n    {\n        // 不需要复印，但还是要实现\n    }\n}\n{% endcodeblock %}\n### 遵循接口分离的示例\nAllInOnePrinter 类只需要实现 IPrinter 接口，而不需要实现不相关的方法。\n{% codeblock lang:C# %}\n\nppublic interface IPrinter\n{\n    void Print();\n}\n\npublic interface IScanner\n{\n    void Scan();\n}\n\npublic interface ICopier\n{\n    void Copy();\n}\n\npublic class AllInOnePrinter : IPrinter\n{\n    public void Print()\n    {\n        // 打印操作\n    }\n}\n\n{% endcodeblock %}\n\n\n## 依赖反转原则\n依赖反转主要强调高层模块**不要直接**依赖底层模块，二者都需要依赖于抽象，具体细节不应该依赖抽象，而抽象应该依赖于具体细节。\n- 高层模块不应该直接依赖底层模块，他们直接要依赖于抽象。\n- 抽象不依赖于具体，具体应该依赖于抽象\n如抽象层，(接口或者抽象类)，以定义高层模块和底层模块之间的通信接口。高层模块依赖于抽象，而具体的底层模块实现这些抽象。\n### 违背依赖反转的示例\nDriver类直接依赖于具体的车型，DriveElectricCar和DriveGasolineCar方法分别依赖于ElectricCar和GasolineCar。这违反了依赖反转，因为高层模块（Driver）直接依赖于低层模块（ElectricCar和GasolineCar）。\n{% codeblock lang:C# %}\npublic class ElectricCar\n{\n    public void Drive()\n    {\n        // 电动车行驶逻辑\n    }\n}\n\npublic class GasolineCar\n{\n    public void Drive()\n    {\n        // 内燃机车行驶逻辑\n    }\n}\n\npublic class Driver\n{\n    public void DriveElectricCar(ElectricCar car)\n    {\n        car.Drive();\n    }\n\n    public void DriveGasolineCar(GasolineCar car)\n    {\n        car.Drive();\n    }\n}\n{% endcodeblock %}\n### 遵守依赖反转的示例\n\n{% codeblock lang:C# %}\npublic interface ICar\n{\n    void Drive();\n}\n引入一个抽象的Car接口，然后让具体的车型实现它。Driver类不再依赖于具体的车型，而是依赖于抽象的Car接口：\npublic class ElectricCar : ICar\n{\n    public void Drive()\n    {\n        // 电动车行驶逻辑\n    }\n}\n\npublic class GasolineCar : ICar\n{\n    public void Drive()\n    {\n        // 内燃机车行驶逻辑\n    }\n}\n\npublic class Driver\n{\n    public void DriveCar(ICar car)\n    {\n        car.Drive();\n    }\n}\n{% endcodeblock %}","source":"_posts/1.计算机编程/SOLID原则.md","raw":"---\ntitle: SOLID原则\ndate: 2019-10-20 09:00:36\ncategories: 设计原则\ntags: \n- 设计原则\n- 面向对象\n---\n# SOLID原则\n## 什么是SOLID\n\n首先SOLOD原则就是一组面向对象编程的设计原则，主要作用是改善软件设计、提高代码质量，增加软件的可维护性和可扩展性。\n\nSOLID相应代表：\n- **S 单一职责原则(Single Responsibility Principle)**\n- **O 开放封闭原则(Open/Closed Principle)**\n- **L 里氏替换原则(Liskov Substiution Principle)**\n- **O 接口隔离原则(Interface Segregation Principle)**\n- **D 依赖反转原则(Dependencey Inversion Principle)**\n\n## 单一职责原则\n单一职责原则主要介绍一个类的责任应该是单一的，它应该只有一个理由去来改变，类里的方法或属性应该与责任有关。每个类都有清晰的目标和职责。\n\n>简单来说让一个程序员去打代码，还要让设计海报，工作变得复杂，容易出错。那么我们要根据单一职责，以确保每项任务得到专业的处理，打代码的就是来代码，设计海报的就来设计海报。\n也可以理解为游戏中的法师、战士、辅助。他们都有特定的任务职责。\n\n### 违反单一职责的示例\n\n{% codeblock lang:C# %}\n/// <summary>\n/// 文件处理类\n/// </summary>\npublic class FileProcessor\n{\n    public string ReadFile(string filePath)\n    {\n        // 读取文件的具体实现\n    }\n\n    public int CountCharacters(string text)\n    {\n        // 统计字符数的具体实现\n    }\n}\n\n{% endcodeblock %}\n\n### 遵循单一职责的示例\n\n\n{% codeblock lang:C# %}\n \npublic class FileReader\n{\n    public string ReadFile(string filePath)\n    {\n        // 读取文件的具体实现\n    }\n}\n\npublic class CharacterCounter\n{\n    public int CountCharacters(string text)\n    {\n        // 统计字符数的具体实现\n    }\n}\n\n{% endcodeblock %}\n## 开放封闭原则\n开放封闭原则主要强调软件实体、类、模块、函数应该对扩展开放，对修改封闭。这意味着添加新的功能或者更改现有功能时，不应该修改已经存在的代码，而是应该通关扩展现有代码来实现。\n\n> 一旦写好一段代码，就不要再去修改他，相反如果添加新的功能，不要动原来的代码，而是在基础之上添加新的东西。如果在修改原来的代码可能会导致原来的功能变的不稳定。通过新的东西，可以确保旧的功能保持不变。\n\n### 违反开放封闭原则的示例\n\n一个图形绘制应用程序，后面添加新需求要求添加一个新的形状。\n{% codeblock lang:C# %}\npublic class Rectangle\n{\n    public double Width { get; set; }\n    public double Height { get; set; }\n}\n\npublic class AreaCalculator\n{\n    public double CalculateArea(object shape)\n    {\n        if (shape is Rectangle)\n        {\n            var rectangle = (Rectangle)shape;\n            return rectangle.Width * rectangle.Height;\n        }\n        // 现在需要添加一个新的形状（例如圆形）的计算，就需要修改这个类。\n        // 这违反了开放封闭原则。\n        else if (shape is Circle)\n        {\n            var circle = (Circle)shape;\n            return Math.PI * Math.Pow(circle.Radius, 2);\n        }\n        return 0;\n    }\n}\n\n{% endcodeblock %}\n\n### 遵循开放封闭原则的示例\n以下代码我们抽象类一个Shape类，定义了一个抽象方法，并有两个子类，每个类负责实现自己的计算面积方法。\n\n{% codeblock lang:C# %}\npublic abstroct class Shape\n{\n  public abstract double CalculateArea();\n\n}\n\npublic class Rectangle : Shape\n{\n    public double Width { get; set; }\n    public double Height { get; set; }\n\n    public override double CalculateArea()\n    {\n        return Width * Height;\n    }\n}\n\npublic class Circle : Shape\n{\n    public double Radius { get; set; }\n\n    public override double CalculateArea()\n    {\n        return Math.PI * Math.Pow(Radius, 2);\n    }\n}\n{% endcodeblock %}\n## 里氏替换原则\n里氏替换原则强调在面向对象中，子类应该能够替换其基类而不引起不一致或错误。如果一个类型是基类，那么它的子类应该可以无缝地替代它。\n- 子类必须保持基类的行为\n- 子类可以扩展基类的功能\n- 子类不应该引入新的错误\n- 子类不应该强制基类行为\n### 违背里氏替换原则的示例：\n假设我们有一个基类 Bird 表示鸟类，它有一个 Fly 方法用于飞翔。\n{% codeblock lang:C# %}\npublic class Bird\n{\n    public void Fly()\n    {\n        Console.WriteLine(\"这只鸟在飞翔\");\n    }\n}\n\n{% endcodeblock %}\n然后，我们创建了一个子类 Penguin 表示企鹅。企鹅是一种鸟，但它不会飞翔。\n{% codeblock lang:C# %}\npublic class Penguin : Bird\n{\n    // 企鹅不能飞，但我们仍然继承了父类的 Fly 方法，这违背了里氏替换原则。\n}\n{% endcodeblock %}\n\n### 遵守里氏替换原则的示例：\n为了遵守里氏替换原则，我们创建一个接口 IFlyable 表示可以飞翔的行为，然后只有能够飞翔的鸟类实现这个接口。\n\n{% codeblock lang:C# %}\npublic interface IFlyable\n{\n    void Fly();\n}\n\npublic class Bird : IFlyable\n{\n    public void Fly()\n    {\n        Console.WriteLine(\"这只鸟在飞翔\");\n    }\n}\n\npublic class Eagle : IFlyable\n{\n    public void Fly()\n    {\n        Console.WriteLine(\"这只鹰在飞翔\");\n    }\n}\n{% endcodeblock %}\n\n## 接口分离原则 \n接口分离原则强调一个类不应该强制实现它用不到的接口。\n- 接口应该小，不应该包含过多的方法\n- 类应该只实现与关系密切的接口，避免实现不相关方法\n- 如果一个接口变得很庞大，应该拆分成小接口\n### 违背接口分离的示例\n{% codeblock lang:C# %}\n\npublic interface IMultiFunctionDevice\n{\n    void Print();\n    void Scan();\n    void Copy();\n}\n//打印机不需要扫描和复印\npublic class AllInOnePrinter : IMultiFunctionDevice\n{\n    public void Print()\n    {\n        // 打印操作\n    }\n\n    public void Scan()\n    {\n        // 不需要扫描，但还是要实现\n    }\n\n    public void Copy()\n    {\n        // 不需要复印，但还是要实现\n    }\n}\n{% endcodeblock %}\n### 遵循接口分离的示例\nAllInOnePrinter 类只需要实现 IPrinter 接口，而不需要实现不相关的方法。\n{% codeblock lang:C# %}\n\nppublic interface IPrinter\n{\n    void Print();\n}\n\npublic interface IScanner\n{\n    void Scan();\n}\n\npublic interface ICopier\n{\n    void Copy();\n}\n\npublic class AllInOnePrinter : IPrinter\n{\n    public void Print()\n    {\n        // 打印操作\n    }\n}\n\n{% endcodeblock %}\n\n\n## 依赖反转原则\n依赖反转主要强调高层模块**不要直接**依赖底层模块，二者都需要依赖于抽象，具体细节不应该依赖抽象，而抽象应该依赖于具体细节。\n- 高层模块不应该直接依赖底层模块，他们直接要依赖于抽象。\n- 抽象不依赖于具体，具体应该依赖于抽象\n如抽象层，(接口或者抽象类)，以定义高层模块和底层模块之间的通信接口。高层模块依赖于抽象，而具体的底层模块实现这些抽象。\n### 违背依赖反转的示例\nDriver类直接依赖于具体的车型，DriveElectricCar和DriveGasolineCar方法分别依赖于ElectricCar和GasolineCar。这违反了依赖反转，因为高层模块（Driver）直接依赖于低层模块（ElectricCar和GasolineCar）。\n{% codeblock lang:C# %}\npublic class ElectricCar\n{\n    public void Drive()\n    {\n        // 电动车行驶逻辑\n    }\n}\n\npublic class GasolineCar\n{\n    public void Drive()\n    {\n        // 内燃机车行驶逻辑\n    }\n}\n\npublic class Driver\n{\n    public void DriveElectricCar(ElectricCar car)\n    {\n        car.Drive();\n    }\n\n    public void DriveGasolineCar(GasolineCar car)\n    {\n        car.Drive();\n    }\n}\n{% endcodeblock %}\n### 遵守依赖反转的示例\n\n{% codeblock lang:C# %}\npublic interface ICar\n{\n    void Drive();\n}\n引入一个抽象的Car接口，然后让具体的车型实现它。Driver类不再依赖于具体的车型，而是依赖于抽象的Car接口：\npublic class ElectricCar : ICar\n{\n    public void Drive()\n    {\n        // 电动车行驶逻辑\n    }\n}\n\npublic class GasolineCar : ICar\n{\n    public void Drive()\n    {\n        // 内燃机车行驶逻辑\n    }\n}\n\npublic class Driver\n{\n    public void DriveCar(ICar car)\n    {\n        car.Drive();\n    }\n}\n{% endcodeblock %}","slug":"1.计算机编程/SOLID原则","published":1,"updated":"2023-10-18T09:41:16.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqv000zjkgl3mrheubq","content":"<h1 id=\"SOLID原则\"><a href=\"#SOLID原则\" class=\"headerlink\" title=\"SOLID原则\"></a>SOLID原则</h1><h2 id=\"什么是SOLID\"><a href=\"#什么是SOLID\" class=\"headerlink\" title=\"什么是SOLID\"></a>什么是SOLID</h2><p>首先SOLOD原则就是一组面向对象编程的设计原则，主要作用是改善软件设计、提高代码质量，增加软件的可维护性和可扩展性。</p>\n<p>SOLID相应代表：</p>\n<ul>\n<li><strong>S 单一职责原则(Single Responsibility Principle)</strong></li>\n<li><strong>O 开放封闭原则(Open&#x2F;Closed Principle)</strong></li>\n<li><strong>L 里氏替换原则(Liskov Substiution Principle)</strong></li>\n<li><strong>O 接口隔离原则(Interface Segregation Principle)</strong></li>\n<li><strong>D 依赖反转原则(Dependencey Inversion Principle)</strong></li>\n</ul>\n<h2 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h2><p>单一职责原则主要介绍一个类的责任应该是单一的，它应该只有一个理由去来改变，类里的方法或属性应该与责任有关。每个类都有清晰的目标和职责。</p>\n<blockquote>\n<p>简单来说让一个程序员去打代码，还要让设计海报，工作变得复杂，容易出错。那么我们要根据单一职责，以确保每项任务得到专业的处理，打代码的就是来代码，设计海报的就来设计海报。<br>也可以理解为游戏中的法师、战士、辅助。他们都有特定的任务职责。</p>\n</blockquote>\n<h3 id=\"违反单一职责的示例\"><a href=\"#违反单一职责的示例\" class=\"headerlink\" title=\"违反单一职责的示例\"></a>违反单一职责的示例</h3><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> 文件处理类</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FileProcessor</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">ReadFile</span>(<span class=\"params\"><span class=\"built_in\">string</span> filePath</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取文件的具体实现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">CountCharacters</span>(<span class=\"params\"><span class=\"built_in\">string</span> text</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 统计字符数的具体实现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遵循单一职责的示例\"><a href=\"#遵循单一职责的示例\" class=\"headerlink\" title=\"遵循单一职责的示例\"></a>遵循单一职责的示例</h3><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FileReader</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">ReadFile</span>(<span class=\"params\"><span class=\"built_in\">string</span> filePath</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取文件的具体实现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">CharacterCounter</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">CountCharacters</span>(<span class=\"params\"><span class=\"built_in\">string</span> text</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 统计字符数的具体实现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"开放封闭原则\"><a href=\"#开放封闭原则\" class=\"headerlink\" title=\"开放封闭原则\"></a>开放封闭原则</h2><p>开放封闭原则主要强调软件实体、类、模块、函数应该对扩展开放，对修改封闭。这意味着添加新的功能或者更改现有功能时，不应该修改已经存在的代码，而是应该通关扩展现有代码来实现。</p>\n<blockquote>\n<p>一旦写好一段代码，就不要再去修改他，相反如果添加新的功能，不要动原来的代码，而是在基础之上添加新的东西。如果在修改原来的代码可能会导致原来的功能变的不稳定。通过新的东西，可以确保旧的功能保持不变。</p>\n</blockquote>\n<h3 id=\"违反开放封闭原则的示例\"><a href=\"#违反开放封闭原则的示例\" class=\"headerlink\" title=\"违反开放封闭原则的示例\"></a>违反开放封闭原则的示例</h3><p>一个图形绘制应用程序，后面添加新需求要求添加一个新的形状。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">double</span> Width &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">double</span> Height &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">AreaCalculator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">double</span> <span class=\"title\">CalculateArea</span>(<span class=\"params\"><span class=\"built_in\">object</span> shape</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shape <span class=\"keyword\">is</span> Rectangle)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> rectangle = (Rectangle)shape;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> rectangle.Width * rectangle.Height;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 现在需要添加一个新的形状（例如圆形）的计算，就需要修改这个类。</span></span><br><span class=\"line\">        <span class=\"comment\">// 这违反了开放封闭原则。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (shape <span class=\"keyword\">is</span> Circle)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> circle = (Circle)shape;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Math.PI * Math.Pow(circle.Radius, <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遵循开放封闭原则的示例\"><a href=\"#遵循开放封闭原则的示例\" class=\"headerlink\" title=\"遵循开放封闭原则的示例\"></a>遵循开放封闭原则的示例</h3><p>以下代码我们抽象类一个Shape类，定义了一个抽象方法，并有两个子类，每个类负责实现自己的计算面积方法。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> abstroct <span class=\"keyword\">class</span> <span class=\"title\">Shape</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"built_in\">double</span> <span class=\"title\">CalculateArea</span>()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> : <span class=\"title\">Shape</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">double</span> Width &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">double</span> Height &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"built_in\">double</span> <span class=\"title\">CalculateArea</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Width * Height;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Circle</span> : <span class=\"title\">Shape</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">double</span> Radius &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"built_in\">double</span> <span class=\"title\">CalculateArea</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.PI * Math.Pow(Radius, <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h2><p>里氏替换原则强调在面向对象中，子类应该能够替换其基类而不引起不一致或错误。如果一个类型是基类，那么它的子类应该可以无缝地替代它。</p>\n<ul>\n<li>子类必须保持基类的行为</li>\n<li>子类可以扩展基类的功能</li>\n<li>子类不应该引入新的错误</li>\n<li>子类不应该强制基类行为</li>\n</ul>\n<h3 id=\"违背里氏替换原则的示例：\"><a href=\"#违背里氏替换原则的示例：\" class=\"headerlink\" title=\"违背里氏替换原则的示例：\"></a>违背里氏替换原则的示例：</h3><p>假设我们有一个基类 Bird 表示鸟类，它有一个 Fly 方法用于飞翔。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Bird</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Fly</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;这只鸟在飞翔&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>然后，我们创建了一个子类 Penguin 表示企鹅。企鹅是一种鸟，但它不会飞翔。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Penguin</span> : <span class=\"title\">Bird</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 企鹅不能飞，但我们仍然继承了父类的 Fly 方法，这违背了里氏替换原则。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遵守里氏替换原则的示例：\"><a href=\"#遵守里氏替换原则的示例：\" class=\"headerlink\" title=\"遵守里氏替换原则的示例：\"></a>遵守里氏替换原则的示例：</h3><p>为了遵守里氏替换原则，我们创建一个接口 IFlyable 表示可以飞翔的行为，然后只有能够飞翔的鸟类实现这个接口。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IFlyable</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Fly</span>()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Bird</span> : <span class=\"title\">IFlyable</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Fly</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;这只鸟在飞翔&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Eagle</span> : <span class=\"title\">IFlyable</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Fly</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;这只鹰在飞翔&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"接口分离原则\"><a href=\"#接口分离原则\" class=\"headerlink\" title=\"接口分离原则\"></a>接口分离原则</h2><p>接口分离原则强调一个类不应该强制实现它用不到的接口。</p>\n<ul>\n<li>接口应该小，不应该包含过多的方法</li>\n<li>类应该只实现与关系密切的接口，避免实现不相关方法</li>\n<li>如果一个接口变得很庞大，应该拆分成小接口</li>\n</ul>\n<h3 id=\"违背接口分离的示例\"><a href=\"#违背接口分离的示例\" class=\"headerlink\" title=\"违背接口分离的示例\"></a>违背接口分离的示例</h3><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IMultiFunctionDevice</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Print</span>()</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Scan</span>()</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Copy</span>()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//打印机不需要扫描和复印</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">AllInOnePrinter</span> : <span class=\"title\">IMultiFunctionDevice</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Print</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 打印操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Scan</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不需要扫描，但还是要实现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Copy</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不需要复印，但还是要实现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"遵循接口分离的示例\"><a href=\"#遵循接口分离的示例\" class=\"headerlink\" title=\"遵循接口分离的示例\"></a>遵循接口分离的示例</h3><p>AllInOnePrinter 类只需要实现 IPrinter 接口，而不需要实现不相关的方法。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ppublic <span class=\"keyword\">interface</span> <span class=\"title\">IPrinter</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Print</span>()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IScanner</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Scan</span>()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">ICopier</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Copy</span>()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">AllInOnePrinter</span> : <span class=\"title\">IPrinter</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Print</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 打印操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"依赖反转原则\"><a href=\"#依赖反转原则\" class=\"headerlink\" title=\"依赖反转原则\"></a>依赖反转原则</h2><p>依赖反转主要强调高层模块<strong>不要直接</strong>依赖底层模块，二者都需要依赖于抽象，具体细节不应该依赖抽象，而抽象应该依赖于具体细节。</p>\n<ul>\n<li>高层模块不应该直接依赖底层模块，他们直接要依赖于抽象。</li>\n<li>抽象不依赖于具体，具体应该依赖于抽象<br>如抽象层，(接口或者抽象类)，以定义高层模块和底层模块之间的通信接口。高层模块依赖于抽象，而具体的底层模块实现这些抽象。</li>\n</ul>\n<h3 id=\"违背依赖反转的示例\"><a href=\"#违背依赖反转的示例\" class=\"headerlink\" title=\"违背依赖反转的示例\"></a>违背依赖反转的示例</h3><p>Driver类直接依赖于具体的车型，DriveElectricCar和DriveGasolineCar方法分别依赖于ElectricCar和GasolineCar。这违反了依赖反转，因为高层模块（Driver）直接依赖于低层模块（ElectricCar和GasolineCar）。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ElectricCar</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Drive</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 电动车行驶逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">GasolineCar</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Drive</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 内燃机车行驶逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Driver</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">DriveElectricCar</span>(<span class=\"params\">ElectricCar car</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        car.Drive();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">DriveGasolineCar</span>(<span class=\"params\">GasolineCar car</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        car.Drive();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"遵守依赖反转的示例\"><a href=\"#遵守依赖反转的示例\" class=\"headerlink\" title=\"遵守依赖反转的示例\"></a>遵守依赖反转的示例</h3><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">ICar</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Drive</span>()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">引入一个抽象的Car接口，然后让具体的车型实现它。Driver类不再依赖于具体的车型，而是依赖于抽象的Car接口：</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ElectricCar</span> : <span class=\"title\">ICar</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Drive</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 电动车行驶逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">GasolineCar</span> : <span class=\"title\">ICar</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Drive</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 内燃机车行驶逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Driver</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">DriveCar</span>(<span class=\"params\">ICar car</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        car.Drive();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"SOLID原则\"><a href=\"#SOLID原则\" class=\"headerlink\" title=\"SOLID原则\"></a>SOLID原则</h1><h2 id=\"什么是SOLID\"><a href=\"#什么是SOLID\" class=\"headerlink\" title=\"什么是SOLID\"></a>什么是SOLID</h2><p>首先SOLOD原则就是一组面向对象编程的设计原则，主要作用是改善软件设计、提高代码质量，增加软件的可维护性和可扩展性。</p>\n<p>SOLID相应代表：</p>\n<ul>\n<li><strong>S 单一职责原则(Single Responsibility Principle)</strong></li>\n<li><strong>O 开放封闭原则(Open&#x2F;Closed Principle)</strong></li>\n<li><strong>L 里氏替换原则(Liskov Substiution Principle)</strong></li>\n<li><strong>O 接口隔离原则(Interface Segregation Principle)</strong></li>\n<li><strong>D 依赖反转原则(Dependencey Inversion Principle)</strong></li>\n</ul>\n<h2 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h2><p>单一职责原则主要介绍一个类的责任应该是单一的，它应该只有一个理由去来改变，类里的方法或属性应该与责任有关。每个类都有清晰的目标和职责。</p>\n<blockquote>\n<p>简单来说让一个程序员去打代码，还要让设计海报，工作变得复杂，容易出错。那么我们要根据单一职责，以确保每项任务得到专业的处理，打代码的就是来代码，设计海报的就来设计海报。<br>也可以理解为游戏中的法师、战士、辅助。他们都有特定的任务职责。</p>\n</blockquote>\n<h3 id=\"违反单一职责的示例\"><a href=\"#违反单一职责的示例\" class=\"headerlink\" title=\"违反单一职责的示例\"></a>违反单一职责的示例</h3><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> 文件处理类</span></span><br><span class=\"line\"><span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FileProcessor</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">ReadFile</span>(<span class=\"params\"><span class=\"built_in\">string</span> filePath</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取文件的具体实现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">CountCharacters</span>(<span class=\"params\"><span class=\"built_in\">string</span> text</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 统计字符数的具体实现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遵循单一职责的示例\"><a href=\"#遵循单一职责的示例\" class=\"headerlink\" title=\"遵循单一职责的示例\"></a>遵循单一职责的示例</h3><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">FileReader</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">string</span> <span class=\"title\">ReadFile</span>(<span class=\"params\"><span class=\"built_in\">string</span> filePath</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 读取文件的具体实现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">CharacterCounter</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">int</span> <span class=\"title\">CountCharacters</span>(<span class=\"params\"><span class=\"built_in\">string</span> text</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 统计字符数的具体实现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"开放封闭原则\"><a href=\"#开放封闭原则\" class=\"headerlink\" title=\"开放封闭原则\"></a>开放封闭原则</h2><p>开放封闭原则主要强调软件实体、类、模块、函数应该对扩展开放，对修改封闭。这意味着添加新的功能或者更改现有功能时，不应该修改已经存在的代码，而是应该通关扩展现有代码来实现。</p>\n<blockquote>\n<p>一旦写好一段代码，就不要再去修改他，相反如果添加新的功能，不要动原来的代码，而是在基础之上添加新的东西。如果在修改原来的代码可能会导致原来的功能变的不稳定。通过新的东西，可以确保旧的功能保持不变。</p>\n</blockquote>\n<h3 id=\"违反开放封闭原则的示例\"><a href=\"#违反开放封闭原则的示例\" class=\"headerlink\" title=\"违反开放封闭原则的示例\"></a>违反开放封闭原则的示例</h3><p>一个图形绘制应用程序，后面添加新需求要求添加一个新的形状。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">double</span> Width &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">double</span> Height &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">AreaCalculator</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"built_in\">double</span> <span class=\"title\">CalculateArea</span>(<span class=\"params\"><span class=\"built_in\">object</span> shape</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shape <span class=\"keyword\">is</span> Rectangle)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> rectangle = (Rectangle)shape;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> rectangle.Width * rectangle.Height;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 现在需要添加一个新的形状（例如圆形）的计算，就需要修改这个类。</span></span><br><span class=\"line\">        <span class=\"comment\">// 这违反了开放封闭原则。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (shape <span class=\"keyword\">is</span> Circle)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> circle = (Circle)shape;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Math.PI * Math.Pow(circle.Radius, <span class=\"number\">2</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遵循开放封闭原则的示例\"><a href=\"#遵循开放封闭原则的示例\" class=\"headerlink\" title=\"遵循开放封闭原则的示例\"></a>遵循开放封闭原则的示例</h3><p>以下代码我们抽象类一个Shape类，定义了一个抽象方法，并有两个子类，每个类负责实现自己的计算面积方法。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> abstroct <span class=\"keyword\">class</span> <span class=\"title\">Shape</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"built_in\">double</span> <span class=\"title\">CalculateArea</span>()</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> : <span class=\"title\">Shape</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">double</span> Width &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">double</span> Height &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"built_in\">double</span> <span class=\"title\">CalculateArea</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Width * Height;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Circle</span> : <span class=\"title\">Shape</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">double</span> Radius &#123; <span class=\"keyword\">get</span>; <span class=\"keyword\">set</span>; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">override</span> <span class=\"built_in\">double</span> <span class=\"title\">CalculateArea</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.PI * Math.Pow(Radius, <span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"里氏替换原则\"><a href=\"#里氏替换原则\" class=\"headerlink\" title=\"里氏替换原则\"></a>里氏替换原则</h2><p>里氏替换原则强调在面向对象中，子类应该能够替换其基类而不引起不一致或错误。如果一个类型是基类，那么它的子类应该可以无缝地替代它。</p>\n<ul>\n<li>子类必须保持基类的行为</li>\n<li>子类可以扩展基类的功能</li>\n<li>子类不应该引入新的错误</li>\n<li>子类不应该强制基类行为</li>\n</ul>\n<h3 id=\"违背里氏替换原则的示例：\"><a href=\"#违背里氏替换原则的示例：\" class=\"headerlink\" title=\"违背里氏替换原则的示例：\"></a>违背里氏替换原则的示例：</h3><p>假设我们有一个基类 Bird 表示鸟类，它有一个 Fly 方法用于飞翔。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Bird</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Fly</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;这只鸟在飞翔&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>然后，我们创建了一个子类 Penguin 表示企鹅。企鹅是一种鸟，但它不会飞翔。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Penguin</span> : <span class=\"title\">Bird</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 企鹅不能飞，但我们仍然继承了父类的 Fly 方法，这违背了里氏替换原则。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"遵守里氏替换原则的示例：\"><a href=\"#遵守里氏替换原则的示例：\" class=\"headerlink\" title=\"遵守里氏替换原则的示例：\"></a>遵守里氏替换原则的示例：</h3><p>为了遵守里氏替换原则，我们创建一个接口 IFlyable 表示可以飞翔的行为，然后只有能够飞翔的鸟类实现这个接口。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IFlyable</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Fly</span>()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Bird</span> : <span class=\"title\">IFlyable</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Fly</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;这只鸟在飞翔&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Eagle</span> : <span class=\"title\">IFlyable</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Fly</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        Console.WriteLine(<span class=\"string\">&quot;这只鹰在飞翔&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"接口分离原则\"><a href=\"#接口分离原则\" class=\"headerlink\" title=\"接口分离原则\"></a>接口分离原则</h2><p>接口分离原则强调一个类不应该强制实现它用不到的接口。</p>\n<ul>\n<li>接口应该小，不应该包含过多的方法</li>\n<li>类应该只实现与关系密切的接口，避免实现不相关方法</li>\n<li>如果一个接口变得很庞大，应该拆分成小接口</li>\n</ul>\n<h3 id=\"违背接口分离的示例\"><a href=\"#违背接口分离的示例\" class=\"headerlink\" title=\"违背接口分离的示例\"></a>违背接口分离的示例</h3><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IMultiFunctionDevice</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Print</span>()</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Scan</span>()</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Copy</span>()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//打印机不需要扫描和复印</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">AllInOnePrinter</span> : <span class=\"title\">IMultiFunctionDevice</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Print</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 打印操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Scan</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不需要扫描，但还是要实现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Copy</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 不需要复印，但还是要实现</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"遵循接口分离的示例\"><a href=\"#遵循接口分离的示例\" class=\"headerlink\" title=\"遵循接口分离的示例\"></a>遵循接口分离的示例</h3><p>AllInOnePrinter 类只需要实现 IPrinter 接口，而不需要实现不相关的方法。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">ppublic <span class=\"keyword\">interface</span> <span class=\"title\">IPrinter</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Print</span>()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">IScanner</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Scan</span>()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">ICopier</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Copy</span>()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">AllInOnePrinter</span> : <span class=\"title\">IPrinter</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Print</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 打印操作</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"依赖反转原则\"><a href=\"#依赖反转原则\" class=\"headerlink\" title=\"依赖反转原则\"></a>依赖反转原则</h2><p>依赖反转主要强调高层模块<strong>不要直接</strong>依赖底层模块，二者都需要依赖于抽象，具体细节不应该依赖抽象，而抽象应该依赖于具体细节。</p>\n<ul>\n<li>高层模块不应该直接依赖底层模块，他们直接要依赖于抽象。</li>\n<li>抽象不依赖于具体，具体应该依赖于抽象<br>如抽象层，(接口或者抽象类)，以定义高层模块和底层模块之间的通信接口。高层模块依赖于抽象，而具体的底层模块实现这些抽象。</li>\n</ul>\n<h3 id=\"违背依赖反转的示例\"><a href=\"#违背依赖反转的示例\" class=\"headerlink\" title=\"违背依赖反转的示例\"></a>违背依赖反转的示例</h3><p>Driver类直接依赖于具体的车型，DriveElectricCar和DriveGasolineCar方法分别依赖于ElectricCar和GasolineCar。这违反了依赖反转，因为高层模块（Driver）直接依赖于低层模块（ElectricCar和GasolineCar）。</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ElectricCar</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Drive</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 电动车行驶逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">GasolineCar</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Drive</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 内燃机车行驶逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Driver</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">DriveElectricCar</span>(<span class=\"params\">ElectricCar car</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        car.Drive();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">DriveGasolineCar</span>(<span class=\"params\">GasolineCar car</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        car.Drive();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"遵守依赖反转的示例\"><a href=\"#遵守依赖反转的示例\" class=\"headerlink\" title=\"遵守依赖反转的示例\"></a>遵守依赖反转的示例</h3><figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title\">ICar</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Drive</span>()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">引入一个抽象的Car接口，然后让具体的车型实现它。Driver类不再依赖于具体的车型，而是依赖于抽象的Car接口：</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ElectricCar</span> : <span class=\"title\">ICar</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Drive</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 电动车行驶逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">GasolineCar</span> : <span class=\"title\">ICar</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Drive</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 内燃机车行驶逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">Driver</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">DriveCar</span>(<span class=\"params\">ICar car</span>)</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        car.Drive();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Windows-Docker安装","date":"2023-11-27T12:49:21.000Z","_content":"# 简单介绍\nDocker是一个流行的容器化平台，运行将应用程序和其他所需依赖打包到一个为容器独立单元中，这些容器可以在任何地方运行。\n简单来说，Docker就是一个小型虚拟计算机，里面可以包含程序的所需要的一切：代码，运行时，系统工具，库或配置。但是与传统虚拟机不通。容器不需要独立的操作系统，他们是共享主机操作系统的内核，更加轻量级和高效。\n# 下载Docker Desktop\nDocker Desktop 是 Docker 在 Windows操作系统上的官方安装方式，这个方法依然属于先在虚拟机中安装 Linux 然后再安装 Docker 的方法。\n## 安装Hyper-v\n``` 控制面板/程序/启动或关闭windows功能/Hyper-V（点击√） ```\n## 安装 WSL 2\n官方地址：https://learn.microsoft.com/zh-cn/windows/wsl/install\n\n这个呢主要是开发人员可以在 Windows 计算机上同时访问 Windows 和 Linux 。\n- 安装子系统\n``` 控制面板/程序/启动或关闭windows功能/适用于Linux 的WindowS子系统（点击√） ```\n\n- 在PowerShell输入：``` wsl --list --online ``` 列出可用发行版列表\n- 在PowerShell输入： ```wsl.exe --install -d <NAME 名称：如:Ubuntu-22.04>```\n- 在PowerShell输入：``` wsl --set-version 命令可用于从 WSL 2 降级到 WSL 1```\n- 查看版本：```wsl -l -v```\n## 下载\n``` https://hub.docker.com/?overlay=onboarding ```\n\n安装完成之后可以输入命令测试：``` docker run hello-world```\n","source":"_posts/1.计算机编程/Windows-Docker安装.md","raw":"---\ntitle: Windows-Docker安装\ndate: 2023-11-27 20:49:21\ntags:\n- Docker\n- 容器\n---\n# 简单介绍\nDocker是一个流行的容器化平台，运行将应用程序和其他所需依赖打包到一个为容器独立单元中，这些容器可以在任何地方运行。\n简单来说，Docker就是一个小型虚拟计算机，里面可以包含程序的所需要的一切：代码，运行时，系统工具，库或配置。但是与传统虚拟机不通。容器不需要独立的操作系统，他们是共享主机操作系统的内核，更加轻量级和高效。\n# 下载Docker Desktop\nDocker Desktop 是 Docker 在 Windows操作系统上的官方安装方式，这个方法依然属于先在虚拟机中安装 Linux 然后再安装 Docker 的方法。\n## 安装Hyper-v\n``` 控制面板/程序/启动或关闭windows功能/Hyper-V（点击√） ```\n## 安装 WSL 2\n官方地址：https://learn.microsoft.com/zh-cn/windows/wsl/install\n\n这个呢主要是开发人员可以在 Windows 计算机上同时访问 Windows 和 Linux 。\n- 安装子系统\n``` 控制面板/程序/启动或关闭windows功能/适用于Linux 的WindowS子系统（点击√） ```\n\n- 在PowerShell输入：``` wsl --list --online ``` 列出可用发行版列表\n- 在PowerShell输入： ```wsl.exe --install -d <NAME 名称：如:Ubuntu-22.04>```\n- 在PowerShell输入：``` wsl --set-version 命令可用于从 WSL 2 降级到 WSL 1```\n- 查看版本：```wsl -l -v```\n## 下载\n``` https://hub.docker.com/?overlay=onboarding ```\n\n安装完成之后可以输入命令测试：``` docker run hello-world```\n","slug":"1.计算机编程/Windows-Docker安装","published":1,"updated":"2023-11-27T13:12:06.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clqhfxjqw0013jkgl90a38ux2","content":"<h1 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h1><p>Docker是一个流行的容器化平台，运行将应用程序和其他所需依赖打包到一个为容器独立单元中，这些容器可以在任何地方运行。<br>简单来说，Docker就是一个小型虚拟计算机，里面可以包含程序的所需要的一切：代码，运行时，系统工具，库或配置。但是与传统虚拟机不通。容器不需要独立的操作系统，他们是共享主机操作系统的内核，更加轻量级和高效。</p>\n<h1 id=\"下载Docker-Desktop\"><a href=\"#下载Docker-Desktop\" class=\"headerlink\" title=\"下载Docker Desktop\"></a>下载Docker Desktop</h1><p>Docker Desktop 是 Docker 在 Windows操作系统上的官方安装方式，这个方法依然属于先在虚拟机中安装 Linux 然后再安装 Docker 的方法。</p>\n<h2 id=\"安装Hyper-v\"><a href=\"#安装Hyper-v\" class=\"headerlink\" title=\"安装Hyper-v\"></a>安装Hyper-v</h2><p><code>控制面板/程序/启动或关闭windows功能/Hyper-V（点击√）</code></p>\n<h2 id=\"安装-WSL-2\"><a href=\"#安装-WSL-2\" class=\"headerlink\" title=\"安装 WSL 2\"></a>安装 WSL 2</h2><p>官方地址：<a href=\"https://learn.microsoft.com/zh-cn/windows/wsl/install\">https://learn.microsoft.com/zh-cn/windows/wsl/install</a></p>\n<p>这个呢主要是开发人员可以在 Windows 计算机上同时访问 Windows 和 Linux 。</p>\n<ul>\n<li>安装子系统</li>\n</ul>\n<p><code>控制面板/程序/启动或关闭windows功能/适用于Linux 的WindowS子系统（点击√）</code></p>\n<ul>\n<li>在PowerShell输入：<code>wsl --list --online</code> 列出可用发行版列表</li>\n<li>在PowerShell输入： <code>wsl.exe --install -d &lt;NAME 名称：如:Ubuntu-22.04&gt;</code></li>\n<li>在PowerShell输入：<code> wsl --set-version 命令可用于从 WSL 2 降级到 WSL 1</code></li>\n<li>查看版本：<code>wsl -l -v</code></li>\n</ul>\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p><code>https://hub.docker.com/?overlay=onboarding</code></p>\n<p>安装完成之后可以输入命令测试：<code> docker run hello-world</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简单介绍\"><a href=\"#简单介绍\" class=\"headerlink\" title=\"简单介绍\"></a>简单介绍</h1><p>Docker是一个流行的容器化平台，运行将应用程序和其他所需依赖打包到一个为容器独立单元中，这些容器可以在任何地方运行。<br>简单来说，Docker就是一个小型虚拟计算机，里面可以包含程序的所需要的一切：代码，运行时，系统工具，库或配置。但是与传统虚拟机不通。容器不需要独立的操作系统，他们是共享主机操作系统的内核，更加轻量级和高效。</p>\n<h1 id=\"下载Docker-Desktop\"><a href=\"#下载Docker-Desktop\" class=\"headerlink\" title=\"下载Docker Desktop\"></a>下载Docker Desktop</h1><p>Docker Desktop 是 Docker 在 Windows操作系统上的官方安装方式，这个方法依然属于先在虚拟机中安装 Linux 然后再安装 Docker 的方法。</p>\n<h2 id=\"安装Hyper-v\"><a href=\"#安装Hyper-v\" class=\"headerlink\" title=\"安装Hyper-v\"></a>安装Hyper-v</h2><p><code>控制面板/程序/启动或关闭windows功能/Hyper-V（点击√）</code></p>\n<h2 id=\"安装-WSL-2\"><a href=\"#安装-WSL-2\" class=\"headerlink\" title=\"安装 WSL 2\"></a>安装 WSL 2</h2><p>官方地址：<a href=\"https://learn.microsoft.com/zh-cn/windows/wsl/install\">https://learn.microsoft.com/zh-cn/windows/wsl/install</a></p>\n<p>这个呢主要是开发人员可以在 Windows 计算机上同时访问 Windows 和 Linux 。</p>\n<ul>\n<li>安装子系统</li>\n</ul>\n<p><code>控制面板/程序/启动或关闭windows功能/适用于Linux 的WindowS子系统（点击√）</code></p>\n<ul>\n<li>在PowerShell输入：<code>wsl --list --online</code> 列出可用发行版列表</li>\n<li>在PowerShell输入： <code>wsl.exe --install -d &lt;NAME 名称：如:Ubuntu-22.04&gt;</code></li>\n<li>在PowerShell输入：<code> wsl --set-version 命令可用于从 WSL 2 降级到 WSL 1</code></li>\n<li>查看版本：<code>wsl -l -v</code></li>\n</ul>\n<h2 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h2><p><code>https://hub.docker.com/?overlay=onboarding</code></p>\n<p>安装完成之后可以输入命令测试：<code> docker run hello-world</code></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clqhfxjqg0001jkgldzrq0024","category_id":"clqhfxjqk0003jkgl0nflgx5l","_id":"clqhfxjqp000cjkglczaaga2n"},{"post_id":"clqhfxjqj0002jkglh47ma4n2","category_id":"clqhfxjqn0008jkgld3zq6y6z","_id":"clqhfxjqq000jjkgl6hragx36"},{"post_id":"clqhfxjqo000bjkgl0cex385i","category_id":"clqhfxjqq000gjkglbp5nc6r9","_id":"clqhfxjqu000ujkgl6tow9ahc"},{"post_id":"clqhfxjqr000njkgl943d7nki","category_id":"clqhfxjqq000gjkglbp5nc6r9","_id":"clqhfxjqv000xjkgl1u80ge58"},{"post_id":"clqhfxjqp000ejkgld00x9e2q","category_id":"clqhfxjqq000gjkglbp5nc6r9","_id":"clqhfxjqw0011jkglflvs00ei"},{"post_id":"clqhfxjqq000hjkglg5u1dh44","category_id":"clqhfxjqq000gjkglbp5nc6r9","_id":"clqhfxjqw0015jkgle7jb7ytc"},{"post_id":"clqhfxjqt000qjkgl7sftdrdl","category_id":"clqhfxjqw0010jkglg867389d","_id":"clqhfxjqx001ajkgl53iladyt"},{"post_id":"clqhfxjqu000sjkgl8ok85zav","category_id":"clqhfxjqw0010jkglg867389d","_id":"clqhfxjqy001djkgl5exn76xi"},{"post_id":"clqhfxjqv000wjkgl6sq2fpwk","category_id":"clqhfxjqw0010jkglg867389d","_id":"clqhfxjqy001fjkgl7b4g86zb"},{"post_id":"clqhfxjqv000zjkgl3mrheubq","category_id":"clqhfxjqx001cjkgl7mrgg3mu","_id":"clqhfxjqy001jjkgl09843y9w"}],"PostTag":[{"post_id":"clqhfxjqg0001jkgldzrq0024","tag_id":"clqhfxjql0004jkgl4xokf70q","_id":"clqhfxjqq000fjkgl38wu3zee"},{"post_id":"clqhfxjqg0001jkgldzrq0024","tag_id":"clqhfxjqo0009jkgl88yw7bfi","_id":"clqhfxjqq000ijkglcjx48d66"},{"post_id":"clqhfxjqj0002jkglh47ma4n2","tag_id":"clqhfxjqp000djkgl7rsr2css","_id":"clqhfxjqr000mjkgl13ri7bw1"},{"post_id":"clqhfxjql0005jkglbirefv75","tag_id":"clqhfxjqr000kjkgl424x7e55","_id":"clqhfxjqu000rjkglegfz1ipi"},{"post_id":"clqhfxjqm0006jkgl76ct18hp","tag_id":"clqhfxjqr000kjkgl424x7e55","_id":"clqhfxjqv000yjkglflc05jkw"},{"post_id":"clqhfxjqn0007jkglavyq7147","tag_id":"clqhfxjqr000kjkgl424x7e55","_id":"clqhfxjqw0014jkglfxdg0yeg"},{"post_id":"clqhfxjqo000ajkgldd2za18h","tag_id":"clqhfxjqw0012jkgl3lba2n48","_id":"clqhfxjqx0018jkgl8asu55hd"},{"post_id":"clqhfxjqo000bjkgl0cex385i","tag_id":"clqhfxjqx0017jkglbmiuetre","_id":"clqhfxjqy001gjkgl0dzz5ta1"},{"post_id":"clqhfxjqo000bjkgl0cex385i","tag_id":"clqhfxjqx001bjkgldoybcghy","_id":"clqhfxjqy001hjkgl1xwk6jtn"},{"post_id":"clqhfxjqp000ejkgld00x9e2q","tag_id":"clqhfxjqy001ejkglb6oi3d1i","_id":"clqhfxjqy001kjkglds7n8je9"},{"post_id":"clqhfxjqq000hjkglg5u1dh44","tag_id":"clqhfxjqy001ejkglb6oi3d1i","_id":"clqhfxjqy001mjkglef3qgl1u"},{"post_id":"clqhfxjqr000ljkglh3cr1jr2","tag_id":"clqhfxjqy001ljkgl4bj76cok","_id":"clqhfxjqz001pjkglal90bfrg"},{"post_id":"clqhfxjqr000ljkglh3cr1jr2","tag_id":"clqhfxjqy001njkglfpbb8gdp","_id":"clqhfxjqz001qjkglfix853z2"},{"post_id":"clqhfxjqr000njkgl943d7nki","tag_id":"clqhfxjqz001ojkgld4q6aw46","_id":"clqhfxjqz001tjkglb99daj39"},{"post_id":"clqhfxjqr000njkgl943d7nki","tag_id":"clqhfxjqz001rjkgl2v8227ss","_id":"clqhfxjqz001ujkgl6ag4gftq"},{"post_id":"clqhfxjqt000qjkgl7sftdrdl","tag_id":"clqhfxjqz001sjkgl18vaa51g","_id":"clqhfxjqz001xjkgl38631xs5"},{"post_id":"clqhfxjqt000qjkgl7sftdrdl","tag_id":"clqhfxjqz001vjkgl5tnc2e1q","_id":"clqhfxjr0001yjkglh4ksglr5"},{"post_id":"clqhfxjqu000sjkgl8ok85zav","tag_id":"clqhfxjqz001sjkgl18vaa51g","_id":"clqhfxjr00021jkgl1d4tbkl2"},{"post_id":"clqhfxjqu000sjkgl8ok85zav","tag_id":"clqhfxjqz001vjkgl5tnc2e1q","_id":"clqhfxjr00022jkglc0f52gsp"},{"post_id":"clqhfxjqv000wjkgl6sq2fpwk","tag_id":"clqhfxjqz001sjkgl18vaa51g","_id":"clqhfxjr00025jkgl2j89eg9a"},{"post_id":"clqhfxjqv000wjkgl6sq2fpwk","tag_id":"clqhfxjqz001vjkgl5tnc2e1q","_id":"clqhfxjr00026jkglbfy62ksn"},{"post_id":"clqhfxjqv000zjkgl3mrheubq","tag_id":"clqhfxjr00024jkglch4a0pmy","_id":"clqhfxjr10029jkgl391tbo1h"},{"post_id":"clqhfxjqv000zjkgl3mrheubq","tag_id":"clqhfxjr00027jkgl6flwc3tg","_id":"clqhfxjr1002ajkgl88ur4jg2"},{"post_id":"clqhfxjqw0013jkgl90a38ux2","tag_id":"clqhfxjr10028jkgl9s43ewpy","_id":"clqhfxjr1002cjkglhn4ygx0d"},{"post_id":"clqhfxjqw0013jkgl90a38ux2","tag_id":"clqhfxjr1002bjkgldiq7b9nc","_id":"clqhfxjr1002djkgl37r2274r"}],"Tag":[{"name":"Git","_id":"clqhfxjql0004jkgl4xokf70q"},{"name":"错误","_id":"clqhfxjqo0009jkgl88yw7bfi"},{"name":"工具","_id":"clqhfxjqp000djkgl7rsr2css"},{"name":"GoLang","_id":"clqhfxjqr000kjkgl424x7e55"},{"name":"计算机编程","_id":"clqhfxjqw0012jkgl3lba2n48"},{"name":"前端笔记","_id":"clqhfxjqx0017jkglbmiuetre"},{"name":"ES6","_id":"clqhfxjqx001bjkgldoybcghy"},{"name":"Node.js","_id":"clqhfxjqy001ejkglb6oi3d1i"},{"name":"HTTP","_id":"clqhfxjqy001ljkgl4bj76cok"},{"name":"web开发","_id":"clqhfxjqy001njkglfpbb8gdp"},{"name":"前端常用命令","_id":"clqhfxjqz001ojkgld4q6aw46"},{"name":"npm","_id":"clqhfxjqz001rjkgl2v8227ss"},{"name":"C#","_id":"clqhfxjqz001sjkgl18vaa51g"},{"name":".Net Core","_id":"clqhfxjqz001vjkgl5tnc2e1q"},{"name":"设计原则","_id":"clqhfxjr00024jkglch4a0pmy"},{"name":"面向对象","_id":"clqhfxjr00027jkgl6flwc3tg"},{"name":"Docker","_id":"clqhfxjr10028jkgl9s43ewpy"},{"name":"容器","_id":"clqhfxjr1002bjkgldiq7b9nc"}]}}